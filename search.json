[{"title":"2021 Archlinux双系统安装教程（超详细）","url":"/2023/05/21/2021-Archlinux%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/","content":"来源：https://zhuanlan.zhihu.com/p/138951848\n如果你不想折腾，直接上Manjaro，如果你喜欢折腾、有时间并且有一定的能力，Arch欢迎你\n这篇教程来帮助那些想用Arch但是又害怕命令行的同学（Arch Wiki写得很详细，但其实对小白来说还是有难度）\n因为截图很重要这里我按照YouTube上一个可靠教程来贴截图讲解\n有条件的也可以直接去看 YouTube原视频\n我的CPU是Intel i5-8250U（x86_64） 启动方式是UEFI而非BIOS（重要）\n显卡是UHD 620+NVIDIA MX150\n安装Arch的硬盘是Samsang 970 EVO（NVME）\n硬盘的类型最好确认一下，如果是NVMe的，先进BIOS修改 从硬盘的启动方式 为AHCI，否则你进入安装界面不会看到你的NVMe硬盘\n为确保一次成功，以下步骤（包括输入的命令）如果你不是很懂不要颠倒顺序，此外请保证安装时有顺畅的网络连接\n因为EFI分区用的是windows的 而这个区还只有100MB 所以建议借助一些分区工具比如傲梅分区进入PE把这个区扩大 具体操作可以直接百度\n0.下载ISOArch Linux - Downloadswww.archlinux.org/download/\n建议去下面找中国的镜像下\n1.硬盘分区分区使用Windows的磁盘管理就行，没必要用DiskGenius\n这里我使用的分区方案是 只额外分一个区来挂载 &#x2F; 目录 EFI利用Windows的EFI分区\n不使用swap分区 而是swap文件\n这里分了250G\n2.制作启动U盘制作工具建议使用 Rufus，写入方式为DD而非ISO，选项那选择GPT而非默认的MBR\n3.BIOS的设置保持上一步制作好的启动U盘一直插着\n开机出现品牌logo时狂按对应键进入BIOS设置比如我的Dell Inspiron就是F12\n进去之后\n1.禁用safeboot 2.如果你的硬盘是NVMe的，把 从硬盘的启动方式 改成 AHCI\n3.修改启动顺序，把U盘的启动顺序放到最上面（此处小心，不要delete任何东西）\n完成之后退出重启\n重启之后就是选择，回车进入arch iso\n4.检查网络输入下面指令检查：\nip a\n\n\n这里用的是有线连接，如果你用的是无线连接需要按照下面的步骤连接到无线网：\n输入\niwctl\n\n进入iwd模式，输入\ndevice list\n\n查看你的网卡名字，这里假设是wlan0，输入\nstation wlan0 scan\n\n检查扫描网络，输入\nstation wlan0 get-networks\n\n查看网络名字，假设名字叫BUPT-portal，输入\nstation wlan0 connect BUPT-portal\n\n接着输入密码（如果有密码的话），输入\nexit\n\n退出iwd模式\n连接成功之后，检查可以连接到pacman源\npacman -Syyy\n\n如图说明一切正常\n重新设置mirrorlist（可选，建议）：\n使用reflector来获取速度最快的6个镜像，并将地址保存至&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist\nreflector -c China -a 6 --sort rate --save /etc/pacman.d/mirrorlist\n\n或者手动添加中科大镜像源\nServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch\n\n\n\n5.硬盘1.检查硬盘\nlsblk\n\n\n这里没有看到之前划分好的空间，不要慌，那是因为之前只是划了空间，并没有建立分区\n2.建立分区\n因为之前划好的空间在nvme0n1上，所以执行\ncfdisk /dev/nvme0n1\n\n这里以你个人情况而定 sda sdb 或是其他的\n这里我们就能看到最后有250G的Free Space\n\n选择New 回车\n\n这里就输入250G 回车\n\n选择Write 回车 输入 yes 回车\n写入完成 选择Quit 回车退出\n检查分区情况\nlsblk\n\n建立分区之后就可以看到分好的250G区\n3.分区格式化\n将刚刚分好的区格式化为ext4格式，这里认准分区号是nvme0n1p5\nmkfs.ext4 /dev/nvme0n1p5\n\n\n4.挂载分区\n先挂载&#x2F;分区，同样，这里分区号也是nvme0n1p5\nmount /dev/nvme0n1p5 /mnt\n\n这里利用Windows的EFI分区，检查EFI分区号\nlsblk\n\n这里可以看到是nvme0n1p2\n建立boot文件夹\nmkdir /mnt/boot\n\n挂载EFI分区\nmount /dev/nvme0n1p2 /mnt/boot\n\n\n6.安装基本系统执行\npacstrap /mnt base linux linux-firmware nano\n\n等待安装完毕\n（如果你不想用默认的内核，也可以使用linux-lts, linux-zen, linux-hardened，具体介绍请看Wiki）\n7.生成fstab文件genfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n\n检查生成的fstab文件\ncat /mnt/etc/fstab\n\n\n如图说明一切正确\n8.正式配置新系统1.切换到装好的系统\narch-chroot /mnt\n\n2.建立swapfile（建议，没有swap空间无法休眠）\n\n在 ext4 上使用 swapfile 的用户请注意，升级到 5.7.x 内核后可能出现诸如「kernel: swapon: swapfile has holes」这样的报错而无法启用 swapfile 。使用 dd 命令创建 swapfile （而非 fallocate） 可能可以解决问题，也可以回退 5.6 系列内核等待上游修复。Arch Linux 错误跟踪：https://bugs.archlinux.org/task/66921内核错误跟踪：https://bugzilla.kernel.org/show_bug.cgi?id&#x3D;207585\n\n如果之前安装的内核是linux-lts：\nfallocate -l 2GB /swapfile\n\n注意：命令中是 小写字母l 而非 数字1 也非 字母i的大写\n如果之前安装的内核不是linux-lts，这里创建swapfile需要使用dd命令：\ndd if=/dev/zero of=/swapfile bs=2048 count=1048576 status=progress\n\n这里分了2G作为swapfile\n改权限\nchmod 600 /swapfile\n\n建立swap空间\nmkswap /swapfile\n\n激活swap空间\nswapon /swapfile\n\n修改&#x2F;etc&#x2F;fstab文件\nnano /etc/fstab\n\n到文件末尾输入\n/swapfile none swap defaults 0 0\n\n\n保存退出\n3.设置时区\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n或\ntimedatectl set-timezone Asia/Shanghai\n\n同步硬件时钟\nhwclock --systohc\n\n4.设置locale\nnano /etc/locale.gen\n\nCtrl+W 输入 #en_US 回车 找到UTF-8那一行 删掉前面的#（取消注释）\nCtrl+W 输入 #zh_CN 回车 找到UTF-8那一行 删掉前面的#（取消注释）\n保存退出\n生成locale\nlocale-gen\n\n创建并写入&#x2F;etc&#x2F;locale.conf文件\nnano /etc/locale.conf \n\n填入内容，注意这里只能填这个\nLANG=en_US.UTF-8\n\n5.创建并写入hostname\nnano /etc/hostname\n\n这里我写入的是 arch 作为hostname，你也可以输别的\n\n保存退出\n6.修改hosts\nnano /etc/hosts\n\n写入内容如图（中间的空白用tab而非空格），arch替换为你之前在hostname里写入的内容，其他都按照图里面的写（注意最后一行的ip是127.0.1.1）\n\n保存退出\n建议上述编辑的内容都用cat输出检查一下\n7.为root用户创建密码\npasswd\n\n然后输入并确认密码（linux终端的密码没有回显，输完直接回车就好）\n8.创建启动器\n安装基本的包，这里使用grub为启动器\npacman -S grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git sudo\n\n如果你不知道这些包的作用，请务必确保输入的指令与上面的一致\n检查完毕回车，需要选择直接回车就好，等待安装结束\n如果你是intel的cpu，需要安装intel的微码文件\npacman -S intel-ucode\n\n如果是amd\npacman -S amd-ucode\n\n\n2021.06.16更新：\n\nGrub 2.06 更新 os-prober 用户需要手动干预\ngrub 2.06 更新已经进入官方源，本次更新有以下两个需要注意的变化：\\1. 如果您正在使用 os-prober 生成其他系统的引导项，grub 2.06 不再自动启用 os-prober，您需要添加 GRUB_DISABLE_OS_PROBER&#x3D;false 至 &#x2F;etc&#x2F;default&#x2F;grub 配置文件中并且重新运行 grub-mkconfig\\2. grub 2.06 现在会自动添加 固件设置菜单 引导项目，无需手动创建\n\n鉴于此需要手动启用os-prober来确保Windows能被正确识别：\n输入\nnano /etc/default/grub\n\n在里面找一条空行输入\nGRUB_DISABLE_OS_PROBER=false\n\n之后Ctrl-X 加Y回车保存退出\n\n完成之后输入\ngrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch\n\n确保输入指令完全正确回车\n\n生成grub.cfg\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n完成之后如图\n\n9.退出新系统并取消挂载exit\n\n\numount -a\n\n\n重启\nreboot\n\n启动时请拔出u盘\n10.进入装好的Arch系统并激活网络进去之后 先输入 root 回车 输入密码 回车\n启动网络服务\nsystemctl enable --now NetworkManager\n\n设置WiFi\nnmtui\n\n\n回车\n\n选择你要连接到的WiFi 输入密码 回车 然后退出\n11.新建用户并授权useradd -m -G wheel mir\n\nwheel后面是你的用户名，这里输入的是mir\n为用户创建密码\npasswd mir\n\n输入并确认密码\n授权\nEDITOR=nano visudo\n\nCtrl+W 输入 # %wheel 回车 找到这行 删除前面的 #（取消注释）\n\n保存退出\n12.安装显卡驱动安装AMD集显驱动\npacman -S xf86-video-amdgpu\n\n安装NVIDIA独显驱动\npacman -S nvidia nvidia-utils\n\n13.安装Display Server这里用的是开源世界最为流行的xorg\npacman -S xorg\n\n出现选择直接回车即可\n14.安装Display Manager这里需要按你要安装的桌面环境而定，这里没有列出的可以自己去ArchWiki查\nGnome：\npacman -S gdm\n\nKDE：\npacman -S sddm\n\nXfce || DDE：\npacman -S lightdm lightdm-gtk-greeter\n\n设置开机自动启动，以gdm为例：\nsystemctl enable gdm\n\n如果是别的请将这里的gdm替换为你安装的那个dm\n15.安装Desktop EnvironmentGnome：\npacman -S gnome\n\nKDE：\npacman -S plasma kde-applications packagekit-qt5\n\nXfce：\npacman -S xfce4 xfce4-goodies\n\nDDE：\npacman -S deepin deepin-extra\n\n同样 需要选择时直接回车\n16.添加archlinuxcn源nano /etc/pacman.conf\n\n在最后加上下面两行（我这里使用了北外的镜像站）\n[archlinuxcn]#Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch#中科大Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n\n同时取消对multilib源的注释\n\n保存退出之后同步并安装archlinuxcn-keyring\npacman -Syu &amp;&amp; pacman -S archlinuxcn-keyring\n\n最后不要忘记安装中文的字体，如果这一步不装进去图形界面之后还是要装：\npacman -S ttf-sarasa-gothic noto-fonts-cjk\n\n我这里安装的是更纱黑体和noto cjk，包比较大，耐心等待安装完毕。\n最后重启\nreboot\n\n在grub界面选择archlinux回车\n当你看到登录界面时，恭喜你，一个相对完整的Arch安装完毕，Enjoy it！\n\n进一步配置可以看看专栏前面那篇Manjaro-KDE的配置，装点常用的软件，大体上就能用了，然后根据自己的情况配配显卡驱动，就差不多能玩游戏了\n关于N卡的启用与切换，建议使用optimus-manager（其他方案我都试过不好使\nsudo pacman -S optimus-manager\n\n没有DE只有一个Bspwm 这是我的dotfiles：\nDracula&amp;Nord Dotfilesgithub.com&#x2F;MiraculousMoon&#x2F;bspwm-dotfiles.git\n此外还有i3wm的：\nhttps://github.com/ayamir/i3-dotfilesgithub.com/ayamir/i3-dotfiles\ndwm的：\nhttps://github.com/ayamir/dwm-dotfilesgithub.com/ayamir/dwm-dotfiles\nspectrwm，xmonad，sway的：\nhttps://github.com/ayamir/nord-and-lightgithub.com/ayamir/nord-and-light\n最后多说一句，如果你装完了，就要意识到自己拥有了Arch WiKi（世界上最好的WiKi之一），这也是Arch用户令人羡慕的一点。遇到问题先找Arch WiKi，再去找别的资料\n","categories":["Linux"],"tags":["Arch"]},{"title":"Debian执行apt-get update提示失败，apt-get upgdate不能被用来加入新的盘片","url":"/2023/05/28/Debian%E6%89%A7%E8%A1%8Capt-get-update%E6%8F%90%E7%A4%BA%E5%A4%B1%E8%B4%A5%EF%BC%8Capt-get-upgdate%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%94%A8%E6%9D%A5%E5%8A%A0%E5%85%A5%E6%96%B0%E7%9A%84%E7%9B%98%E7%89%87/","content":"sudo gedit /etc/apt/sources.list\n\n替换镜像源，注释掉原有的镜像源，这里存放了阿里云、腾讯云、网易三个镜像源，只启用阿里云的镜像源，如下修改：\n# deb cdrom:[Debian GNU/Linux 11.3.0 _Bullseye_ - Official amd64 DVD Binary-1 20220326-11:23]/ bullseye contrib main #deb cdrom:[Debian GNU/Linux 11.3.0 _Bullseye_ - Official amd64 DVD Binary-1 20220326-11:23]/ bullseye contrib main #deb http://security.debian.org/debian-security bullseye-security main contrib#deb-src http://security.debian.org/debian-security bullseye-security main contrib # bullseye-updates, to get updates before a point release is made;# see https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_updates_and_backports# A network mirror was not selected during install.  The following entries# are provided as examples, but you should amend them as appropriate# for your mirror of choice.## deb http://deb.debian.org/debian/ bullseye-updates main contrib# deb-src http://deb.debian.org/debian/ bullseye-updates main contrib  #Aliyun Apt Source 阿里云镜像源deb http://mirrors.aliyun.com/debian/ bullseye main contribdeb-src http://mirrors.aliyun.com/debian/ bullseye main contribdeb http://mirrors.aliyun.com/debian/ bullseye-updates main contribdeb-src http://mirrors.aliyun.com/debian/ bullseye-updates main contribdeb http://mirrors.aliyun.com/debian/ bullseye-backports main contribdeb-src http://mirrors.aliyun.com/debian/ bullseye-backports main contribdeb http://mirrors.aliyun.com/debian/ bullseye-proposed-updates main contribdeb-src http://mirrors.aliyun.com/debian/ bullseye-proposed-updates main contrib  #Tencent Apt Source 腾讯云镜像源#deb https://mirrors.tencent.com/debian/ bullseye main non-free contrib#deb-src https://mirrors.tencent.com/debian/ bullseye main non-free contrib#deb https://mirrors.tencent.com/debian-security/ bullseye-security main#deb-src https://mirrors.tencent.com/debian-security/ bullseye-security main#deb https://mirrors.tencent.com/debian/ bullseye-updates main non-free contrib#deb-src https://mirrors.tencent.com/debian/ bullseye-updates main non-free contrib#deb https://mirrors.tencent.com/debian/ bullseye-backports main non-free contrib#deb-src https://mirrors.tencent.com/debian/ bullseye-backports main non-free contrib #163 Apt Source 网易镜像源#deb https://mirrors.163.com/debian/ bullseye main non-free contrib#deb-src https://mirrors.163.com/debian/ bullseye main non-free contrib#deb https://mirrors.163.com/debian-security/ bullseye-security main#deb-src https://mirrors.163.com/debian-security/ bullseye-security main#deb https://mirrors.163.com/debian/ bullseye-updates main non-free contrib#deb-src https://mirrors.163.com/debian/ bullseye-updates main non-free contrib#deb https://mirrors.163.com/debian/ bullseye-backports main non-free contrib#deb-src https://mirrors.163.com/debian/ bullseye-backports main non-free contrib\n\n最后执行：\nsudo apt-get upgrade\n\n","categories":["Linux"],"tags":["Debian"]},{"title":"Docker+Clash 部署透明“网关”的实现","url":"/2023/05/21/Docker-Clash-%E9%83%A8%E7%BD%B2%E9%80%8F%E6%98%8E%E2%80%9C%E7%BD%91%E5%85%B3%E2%80%9D%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"前言：偶然发现原来Docker里面的Clash也能进行全局网络接管，研究了一下，目前网络上的相关文章较少，且有些在实现上有错误。\n故而整理出来这篇文章，仅供学习交流使用。\n我会详细的解释一些设置和步骤，即便是基础知识薄弱也应该可以看懂。\n\n \n1. Clash在Docker中的部署1.1 部署可视化clash dashboard容器首先将dashboard的image pull下来。\ndocker pull haishanh/yacd\n\n然后直接跑起来就行，注意映射一个没在使用的端口就行\ndocker run -p 1234:80 -d haishanh/yacd\n\n在浏览器键入服务器地址跟端口号，我这里是输入192.168.199.10:1234，就可以打开dashboard页面\n\n1.2 部署clash容器准备好你的配置文件config.yaml，节点和订阅得自己想办法，这里不提供，而且我也不认识毒药是谁。\n将下边的代码覆盖入你原有的基础配置\nport: 7890socks-port: 7891#转发端口一定要配置redir-port: 7892#允许接管局域网流量allow-lan: true#默认代理模式mode: Rulelog-level: warning#接口控制端口你可以自己设置，默认是9090external-controller: 0.0.0.0:7070#如果服务器对公网开放可以设置密码secret: &quot;&quot;#external-ui: dashboard#配置由clash接管的dns解析dns:  enable: true#主要监听定向转发来的数据，后续会在路由表里配置转发端口为1053  listen: 0.0.0.0:1053  enhanced-mode: redir-host#见下方链接  nameserver:    - &#x27;114.114.114.114&#x27;    - &#x27;223.5.5.5&#x27;  fallback:    - &#x27;tls://1.1.1.1:853&#x27;    - &#x27;tcp://1.1.1.1:53&#x27;    - &#x27;tcp://208.67.222.222:443&#x27;    - &#x27;tls://dns.google&#x27;\n\n关于配置文件中的nameserver与fallback的运行与解析机制，详见下方链接。\nDNS污染对Clash（for Windows）的影响 · Fndroid&#x2F;clash_for_windows_pkg Wiki (github.com)github.com&#x2F;Fndroid&#x2F;clash_for_windows_pkg&#x2F;wiki&#x2F;DNS%E6%B1%A1%E6%9F%93%E5%AF%B9Clash%EF%BC%88for-Windows%EF%BC%89%E7%9A%84%E5%BD%B1%E5%93%8D\n准备好配置文件之后 ，运行如下命令启动clash容器\ndocker pull dreamacro/clashdocker run --name Clash -d -v ~/clash/config.yaml:/root/.config/clash/config.yaml --network=&quot;host&quot; --privileged dreamacro/clash\n\n其中 -v 命令之后的挂载卷映射的左侧原始路径要改成你自己的config.yaml的位置。\n如果配置文件设置无误的话，可以在dashboard页面输入服务器地址与端口，链接到clash进行设置了。\n\n\n2. 配置路由表2.1. 配置服务器路由表转发规则可以终端中输入以下命令，也可以写进.sh脚本，chmod +x 之后执行.&#x2F;xxx.sh。\n#在nat表中新建一个clash规则链iptables -t nat -N CLASH#排除环形地址与保留地址，匹配之后直接RETURNiptables -t nat -A CLASH -d 0.0.0.0/8 -j RETURNiptables -t nat -A CLASH -d 10.0.0.0/8 -j RETURNiptables -t nat -A CLASH -d 127.0.0.0/8 -j RETURNiptables -t nat -A CLASH -d 169.254.0.0/16 -j RETURNiptables -t nat -A CLASH -d 172.16.0.0/12 -j RETURNiptables -t nat -A CLASH -d 192.168.0.0/16 -j RETURNiptables -t nat -A CLASH -d 224.0.0.0/4 -j RETURNiptables -t nat -A CLASH -d 240.0.0.0/4 -j RETURN#重定向tcp流量到本机7892端口iptables -t nat -A CLASH -p tcp -j REDIRECT --to-port 7892#拦截外部tcp数据并交给clash规则链处理iptables -t nat -A PREROUTING -p tcp -j CLASH#在nat表中新建一个clash_dns规则链iptables -t nat -N CLASH_DNS#清空clash_dns规则链iptables -t nat -F CLASH_DNS#重定向udp流量到本机1053端口iptables -t nat -A CLASH_DNS -p udp -j REDIRECT --to-port 1053#抓取本机产生的53端口流量交给clash_dns规则链处理iptables -t nat -I OUTPUT -p udp --dport 53 -j CLASH_DNS#拦截外部upd的53端口流量交给clash_dns规则链处理iptables -t nat -I PREROUTING -p udp --dport 53 -j CLASH_DNS\n\n执行之后可以先采取设置非侵入式网关来测试一下服务器上的clash代理与dns解析是否成功。\n2.2 路由表持久化路由表每次重新开机之后都会回复为默认值，如果想要将更改的内容持久化，需要借助一个软件包 iptables-persistent 实现。\nsudo apt install iptables-persistent\n\n第一次安装时会问询是否保存当前路由表配置，保存之后每次重启就都可以恢复为保存时的配置。\n如果对路由表有所修改，需要重新保存，则运行如下命令。\nsudo dpkg-reconfigure iptables-persistent\n\n2.3 路由表复原如果需要删除上述的路由表配置，执行以下命令\niptables -t nat -D PREROUTING -p tcp -j CLASHiptables -t nat -D OUTPUT -p udp --dport 53 -j CLASH_DNSiptables -t nat -D PREROUTING -p udp --dport 53 -j CLASH_DNSiptables -t nat -F CLASHiptables -t nat -X CLASHiptables -t nat -F CLASHiptables -t nat -X CLASH_DNS\n\n\n3. 两种流量接管方式3.1 非侵入式手动设置需要被接管流量的终端设备的IP地址，将网关地址与DNS服务器地址设置为你部署clash的服务器地址。\n\n此种方式为终端设备主动寻求流量接管。\n优点是如果服务器宕机，局域网里的其他联网设备不受影响。\n缺点是每一个需要接管的设备都需要手动设置，较为麻烦。\n3.2 侵入式手动设置服务器的网关地址为主路由器\nvim /etc/network/interfaces\n\n在interfaces里追加下边的参数\nauto eth0iface eth0 inet static  address 192.168.199.10  netmask 255.255.255.0  gateway 192.168.199.1\n\n其中address填写你为clash服务器手动设置的地址, gateway填写主路由器地址, reboot。\n登录路由器后台，在内网DHCP配置页面，将网关与DNS服务器都设置为clash服务器的IP地址。\n\n这样设置下，由主路由器分发给所有终端设备clash服务器的地址作为网关与dns解析接口\nclash服务器处理完数据包之后发送回主路由器，并由主路由器向上送至光猫。\n此时网络才是通的，实现的是旁路由的原理。\n这种方法将由clash服务器全权接管局域网内的所有流量。\n好处是在局域网覆盖范围内只要接入，直接走代理，不需要进行任何设置。\n缺点是一旦服务器宕机，整个局域网就瘫痪了。\n\nTips：打通整个网络，除了配置要没有错误之外，以下三点要反复确认\n\ndocker里的clash在运行状态\n路由表配置完毕\nclash服务器网关地址指向主路由器\n\n\n附录：我是在Friendlyarm NanoPi M4V2 开发板上刷写armbian操作系统进行的上述操作。\n故而理论上所有包括开发板，电视盒之内的能运行Linux系统的设备都可以拿来用。\n至于在Docker之外直接在操作系统上部署Clash的文章有很多，不过透明代理的部分依旧可以参考我这篇文章。\n","tags":["Docker"]},{"title":"Docker 安装","url":"/2023/05/21/Docker-%E5%AE%89%E8%A3%85/","content":"CentOS Docker 安装Docker 支持以下的 64 位 CentOS 版本：\n\nCentOS 7\nCentOS 8\n更高版本…\n\n\n使用官方安装脚本自动安装安装命令如下：\ncurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n\n也可以使用国内 daocloud 一键安装命令：\ncurl -sSL https://get.daocloud.io/docker | sh\n\n\n手动安装卸载旧版本较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。\n$ sudo yum remove docker                   docker-client                   docker-client-latest                   docker-common                   docker-latest                   docker-latest-logrotate                   docker-logrotate                   docker-engine\n安装 Docker Engine-Community使用 Docker 仓库进行安装在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。\n设置仓库\n安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。\n$ sudo yum install -y yum-utils   device-mapper-persistent-data   lvm2\n使用以下命令来设置稳定的仓库。\n使用官方源地址（比较慢）$ sudo yum-config-manager     –add-repo     https:**&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;**docker-ce.repo\n可以选择国内的一些源地址：\n阿里云$ sudo yum-config-manager     –add-repo     http:**&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;**docker-ce.repo\n清华大学源$ sudo yum-config-manager     –add-repo     https:**&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;**docker-ce.repo\n安装 Docker Engine-Community安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本：\n$ sudo yum install docker-ce docker-ce-cli containerd.io\n\n如果提示您接受 GPG 密钥，请选是。\n\n有多个 Docker 仓库吗？\n如果启用了多个 Docker 仓库，则在未在 yum install 或 yum update 命令中指定版本的情况下，进行的安装或更新将始终安装最高版本，这可能不适合您的稳定性需求。\n\nDocker 安装完默认未启动。并且已经创建好 docker 用户组，但该用户组下没有用户。\n要安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：\n1、列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。\n$ yum list docker-ce –showduplicates | sort -r\ndocker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stabledocker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stabledocker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stabledocker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable\n2、通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。\n$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io\n\n启动 Docker。\n$ sudo systemctl start docker\n\n通过运行 hello-world 镜像来验证是否正确安装了 Docker Engine-Community 。\n$ sudo docker run hello-world\n\n卸载 docker删除安装包：\nyum remove docker-ce\n\n删除镜像、容器、配置文件等内容：\nrm -rf /var/lib/docker\n\n\n\nUbuntu Docker 安装Docker Engine-Community 支持以下的 Ubuntu 版本：\n\nXenial 16.04 (LTS)\nBionic 18.04 (LTS)\nCosmic 18.10\nDisco 19.04\n其他更新的版本……\n\nDocker Engine - Community 支持上 x86_64（或 amd64）armhf，arm64，s390x （IBM Z），和 ppc64le（IBM的Power）架构。\n\n使用官方安装脚本自动安装安装命令如下：\ncurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n\n也可以使用国内 daocloud 一键安装命令：\ncurl -sSL https://get.daocloud.io/docker | sh\n\n\n手动安装卸载旧版本Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：\n$ sudo apt-get remove docker docker-engine docker.io containerd runc\n\n当前称为 Docker Engine-Community 软件包 docker-ce 。\n安装 Docker Engine-Community，以下介绍两种方式。\n使用 Docker 仓库进行安装在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker 。\n设置仓库更新 apt 包索引。\n$ sudo apt-get update\n\n安装 apt 依赖包，用于通过HTTPS来获取仓库:\n$ sudo apt-get install     apt-transport-https     ca-certificates     curl     gnupg-agent     software-properties-common\n添加 Docker 的官方 GPG 密钥：\n$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n\n9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。\n$ sudo apt-key fingerprint 0EBFCD88\npub   rsa4096 2017-02-22 [SCEA]      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid           [ unknown**]** Docker Release (CE deb) &lt;**docker**@**docker.com**&gt;sub   rsa4096 2017-02-22 [S]\n使用以下指令设置稳定版仓库\n$ sudo add-apt-repository    “deb [arch&#x3D;amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ **  $(lsb_release -cs) **  stable”\n安装 Docker Engine-Community更新 apt 包索引。\n$ sudo apt-get update\n\n安装最新版本的 Docker Engine-Community 和 containerd ，或者转到下一步安装特定版本：\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n\n要安装特定版本的 Docker Engine-Community，请在仓库中列出可用版本，然后选择一种安装。列出您的仓库中可用的版本：\n$ apt-cache madison docker-ce\n  docker-ce | 5:18.09.13-0ubuntu-xenial | https:**&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages  docker-ce | 5:18.09.03-0ubuntu-xenial | https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages  docker-ce | 18.06.1ce3-0~ubuntu       | https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages  docker-ce | 18.06.0ce3-0~ubuntu       | https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu  xenial&#x2F;**stable amd64 Packages  …\n使用第二列中的版本字符串安装特定版本，例如 5:18.09.13-0ubuntu-xenial。\n$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io\n\n测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功:\n$ sudo docker run hello-world\nUnable to find image ‘hello-world:latest’ locallylatest: Pulling from library&#x2F;hello-world1b930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5fStatus: Downloaded newer image for hello-world:latest\nHello from Docker!This message shows that your installation appears to be working correctly.\nTo generate this message, Docker took the following steps:\n\nThe Docker client contacted the Docker daemon.\nThe Docker daemon pulled the “hello-world” image from the Docker Hub.   (amd64)\nThe Docker daemon created a new container from that image which runs the   executable that produces the output you are currently reading.\nThe Docker daemon streamed that output to the Docker client, which sent it   to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash\nShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/\nFor more examples and ideas, visit: https://docs.docker.com/get-started/\n\n使用 Shell 脚本进行安装Docker 在 get.docker.com 和 test.docker.com 上提供了方便脚本，用于将快速安装 Docker Engine-Community 的边缘版本和测试版本。脚本的源代码在 docker-install 仓库中。 不建议在生产环境中使用这些脚本，在使用它们之前，您应该了解潜在的风险：\n\n脚本需要运行 root 或具有 sudo 特权。因此，在运行脚本之前，应仔细检查和审核脚本。\n这些脚本尝试检测 Linux 发行版和版本，并为您配置软件包管理系统。此外，脚本不允许您自定义任何安装参数。从 Docker 的角度或您自己组织的准则和标准的角度来看，这可能导致不支持的配置。\n这些脚本将安装软件包管理器的所有依赖项和建议，而无需进行确认。这可能会安装大量软件包，具体取决于主机的当前配置。\n该脚本未提供用于指定要安装哪个版本的 Docker 的选项，而是安装了在 edge 通道中发布的最新版本。\n如果已使用其他机制将 Docker 安装在主机上，请不要使用便捷脚本。\n\n本示例使用 get.docker.com 上的脚本在 Linux 上安装最新版本的Docker Engine-Community。要安装最新的测试版本，请改用 test.docker.com。在下面的每个命令，取代每次出现 get 用 test。\n$ curl -fsSL https://get.docker.com -o get-docker.sh$ sudo sh get-docker.sh\n\n如果要使用 Docker 作为非 root 用户，则应考虑使用类似以下方式将用户添加到 docker 组：\n$ sudo usermod -aG docker your-user\n\n卸载 docker删除安装包：\nsudo apt-get purge docker-ce\n\n删除镜像、容器、配置文件等内容：\nsudo rm -rf /var/lib/docker\n\n\n\nDebian Docker 安装Docker 支持以下的 Debian 版本：\n\nBuster 10\nStretch 9 (stable) &#x2F; Raspbian Stretch\n\nDocker Engine-Community 在 x86_64（或 amd64 ）armhf，和 arm64 体系结构上受支持。\n\n使用官方安装脚本自动安装安装命令如下：\ncurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n\n也可以使用国内 daocloud 一键安装命令：\ncurl -sSL https://get.daocloud.io/docker | sh\n\n\n手动安装卸载旧版本Docker 的旧版本被称为 docker，docker.io 或 docker-engine，如果已安装，请卸载它们：\n$ sudo apt-get remove docker docker-engine docker.io containerd runc\n\n安装 Docker Engine-Community使用 Docker 仓库进行安装在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。\nRaspbian 用户不能使用此方法！\n对于 Raspbian，尚不支持使用仓库进行安装。您必须改为使用 shell 脚本方式。\n设置仓库更新 apt 包索引。\n$ sudo apt-get update\n\n安装 apt 依赖包，用于通过 HTTPS 来获取仓库。\n$ sudo apt-get install     apt-transport-https     ca-certificates     curl     gnupg2     software-properties-common\n添加 Docker 的官方 GPG 密钥：\n$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -\n\n9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。\n$ sudo apt-key fingerprint 0EBFCD88\npub   4096R**&#x2F;0EBFCD88 2017-02-22      Key fingerprint &#x3D; 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88uid                  Docker Release (CE deb) &lt;**docker**@**docker.com**&gt;sub   4096R&#x2F;**F273FCD8 2017-02-22\n使用以下指令设置稳定版仓库：\n$ sudo add-apt-repository    “deb [arch&#x3D;amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian **  $(lsb_release -cs) **  stable”\n安装 Docker Engine-Community更新 apt 包索引：\n$ sudo apt-get update\n\n安装最新版本的 Docker Engine-Community 和 containerd ，或者转到下一步安装特定版本：\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n\n要安装特定版本的 Docker Engine-Community，请在仓库中列出可用版本，然后选择一种安装。列出您的仓库中可用的版本：\n$ apt-cache madison docker-ce\n  docker-ce | 5:18.09.13-0debian-stretch | https:**&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;debian stretch&#x2F;stable amd64 Packages  docker-ce | 5:18.09.03-0debian-stretch | https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;debian stretch&#x2F;stable amd64 Packages  docker-ce | 18.06.1ce3-0~debian        | https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;debian stretch&#x2F;stable amd64 Packages  docker-ce | 18.06.0ce3-0~debian        | https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;debian stretch&#x2F;**stable amd64 Packages  …\n使用第二列中的版本字符串安装特定版本，例如 5:18.09.13-0debian-stretch 。\n$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io\n\n测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功：\n$ sudo docker run hello-world\nUnable to find image ‘hello-world:latest’ locallylatest: Pulling from library&#x2F;hello-world1b930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5fStatus: Downloaded newer image for hello-world:latest\nHello from Docker!This message shows that your installation appears to be working correctly.\nTo generate this message, Docker took the following steps:\n\nThe Docker client contacted the Docker daemon.\nThe Docker daemon pulled the “hello-world” image from the Docker Hub.   (amd64)\nThe Docker daemon created a new container from that image which runs the   executable that produces the output you are currently reading.\nThe Docker daemon streamed that output to the Docker client, which sent it   to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash\nShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/\nFor more examples and ideas, visit: https://docs.docker.com/get-started/\n卸载 docker删除安装包：\nsudo apt-get purge docker-ce\n\n删除镜像、容器、配置文件等内容：\nsudo rm -rf /var/lib/docker\n\n\n\nWindows Docker 安装Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。\nDocker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。\n因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。\n\n在 Windows 上部署 Docker 的方法都是先安装一个虚拟机，并在安装 Linux 系统的的虚拟机中运行 Docker。\nWin10 系统Docker Desktop 是 Docker 在 Windows 10 和 macOS 操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。\nDocker Desktop 官方下载地址： https://docs.docker.com/desktop/install/windows-install/\n注意：此方法仅适用于 Windows 10 操作系统专业版、企业版、教育版和部分家庭版！\n安装 Hyper-VHyper-V 是微软开发的虚拟机，类似于 VMWare 或 VirtualBox，仅适用于 Windows 10。这是 Docker Desktop for Windows 所使用的虚拟机。\n但是，这个虚拟机一旦启用，QEMU、VirtualBox 或 VMWare Workstation 15 及以下版本将无法使用！如果你必须在电脑上使用其他虚拟机（例如开发 Android 应用必须使用的模拟器），请不要使用 Hyper-V！\n开启 Hyper-V\n程序和功能\n\n启用或关闭Windows功能\n\n选中Hyper-V\n\n也可以通过命令来启用 Hyper-V ，请右键开始菜单并以管理员身份运行 PowerShell，执行以下命令：\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All\n\n安装 Docker Desktop for Windows点击 Get started with Docker Desktop，并下载 Windows 的版本，如果你还没有登录，会要求注册登录：\n\n运行安装文件双击下载的 Docker for Windows Installer 安装文件，一路 Next，点击 Finish 完成安装。\n\n\n安装完成后，Docker 会自动启动。通知栏上会出现个小鲸鱼的图标，这表示 Docker 正在运行。\n桌边也会出现三个图标，如下图所示：\n我们可以在命令行执行 docker version 来查看版本号，docker run hello-world 来载入测试镜像测试。\n如果没启动，你可以在 Windows 搜索 Docker 来启动：\n\n启动后，也可以在通知栏上看到小鲸鱼图标：\n\n\n如果启动中遇到因 WSL 2 导致地错误，请安装 WSL 2。\n\n安装之后，可以打开 PowerShell 并运行以下命令检测是否运行成功：\ndocker run hello-world\n\n在成功运行之后应该会出现以下信息：\n\n\nwin7、win8 系统win7、win8 等需要利用 docker toolbox 来安装，国内可以使用阿里云的镜像来下载，下载地址：http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/\n安装比较简单，双击运行，点下一步即可，可以勾选自己需要的组件：\n\ndocker toolbox 是一个工具集，它主要包含以下一些内容：\n\nDocker CLI - 客户端，用来运行 docker 引擎创建镜像和容器。\nDocker Machine - 可以让你在 Windows 的命令行中运行 docker 引擎命令。\nDocker Compose - 用来运行 docker-compose 命令。\nKitematic - 这是 Docker 的 GUI 版本。\nDocker QuickStart shell - 这是一个已经配置好Docker的命令行环境。\nOracle VM Virtualbox - 虚拟机。\n\n下载完成之后直接点击安装，安装成功后，桌边会出现三个图标，如下图所示：\n\n点击 Docker QuickStart 图标来启动 Docker Toolbox 终端。\n如果系统显示 User Account Control 窗口来运行 VirtualBox 修改你的电脑，选择 Yes。\n\n$ 符号那里可以输入以下命令来执行。\n$ docker run hello-world Unable to find image &#x27;hello-world:latest&#x27; locally Pulling repository hello-world 91c95931e552: Download complete a8219747be10: Download complete Status: Downloaded newer image for hello-world:latest Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps:  1. The Docker Engine CLI client contacted the Docker Engine daemon.  2. The Docker Engine daemon pulled the &quot;hello-world&quot; image from the Docker Hub.     (Assuming it was not already locally available.)  3. The Docker Engine daemon created a new container from that image which runs the     executable that produces the output you are currently reading.  4. The Docker Engine daemon streamed that output to the Docker Engine CLI client, which sent it     to your terminal. To try something more ambitious, you can run an Ubuntu container with:  $ docker run -it ubuntu bash For more examples and ideas, visit:  https://docs.docker.com/userguide/\n\n\n\nMacOS Docker 安装使用 Homebrew 安装macOS 我们可以使用 Homebrew 来安装 Docker。\nHomebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：\n$ brew install --cask --appdir=/Applications docker==&gt; Creating Caskroom at /usr/local/Caskroom==&gt; We&#x27;ll set permissions properly so we won&#x27;t need sudo in the futurePassword:          # 输入 macOS 密码==&gt; Satisfying dependencies==&gt; Downloading https://download.docker.com/mac/stable/21090/Docker.dmg######################################################################## 100.0%==&gt; Verifying checksum for Cask docker==&gt; Installing Cask docker==&gt; Moving App &#x27;Docker.app&#x27; to &#x27;/Applications/Docker.app&#x27;.&amp;#x1f37a;  docker was successfully installed!\n\n在载入 Docker app 后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有有个小鲸鱼的图标（）。\n\n手动下载安装如果需要手动下载，请点击以下链接下载 Install Docker Desktop on Mac 。\n\n如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到 Application 文件夹即可。\n\n从应用中找到 Docker 图标并点击运行。可能会询问 macOS 的登陆密码，输入即可。\n\n点击顶部状态栏中的鲸鱼图标会弹出操作菜单。\n\n\n第一次点击图标，可能会看到这个安装成功的界面，点击 “Got it!” 可以关闭这个窗口。\n\n启动终端后，通过命令可以检查安装后的 Docker 版本。\n$ docker --versionDocker version 17.09.1-ce, build 19e2cf6\n\n镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。\n在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。\n\n之后我们可以通过 docker info 来查看是否配置成功。\n$ docker info...Registry Mirrors: http://hub-mirror.c.163.comLive Restore Enabled: false\n\n\n\nDocker 镜像加速国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：\n\n科大镜像：https://docker.mirrors.ustc.edu.cn/\n网易：https://hub-mirror.c.163.com/\n阿里云：https:&#x2F;&#x2F;&lt;你的ID&gt;.mirror.aliyuncs.com\n七牛云加速器：https://reg-mirror.qiniu.com\n\n当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。\n阿里云镜像获取地址：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了：\n\n之前还有 Docker 官方加速器 https://registry.docker-cn.com ，现在好像已经不能使用了，我们可以多添加几个国内的镜像，如果有不能使用的，会切换到可以使用个的镜像来拉取。\nUbuntu14.04、Debian7Wheezy对于使用 upstart 的系统而言，编辑 &#x2F;etc&#x2F;default&#x2F;docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：\nDOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;\n\n重新启动服务:\n$ sudo service docker restart\n\nUbuntu16.04+、Debian8+、CentOS7对于使用 systemd 的系统，请在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）：\n&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;\n\n之后重新启动服务：\n$ sudo systemctl daemon-reload$ sudo systemctl restart docker\nWindows 10对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registrymirrors 一栏中填写加速器地址 https://docker.mirrors.ustc.edu.cn/ ，之后点击 Apply 保存后 Docker 就会重启并应用配置的镜像地址了。\n\nMac OS X对于使用 Mac OS X 的用户，在任务栏点击 Docker for mac 应用图标-&gt; Perferences…-&gt; Daemon-&gt; Registrymirrors。在列表中填写加速器地址 https://reg-mirror.qiniu.com 。修改完成之后，点击 Apply&amp;Restart 按钮，Docker 就会重启并应用配置的镜像地址了。\n\n检查加速器是否生效检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。\n$ docker infoRegistry Mirrors:    https://reg-mirror.qiniu.com","tags":["Docker"]},{"title":"Druid配置参数详解","url":"/2023/05/21/Druid%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/","content":"pom引入&lt;dependency&gt;          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;          &lt;artifactId&gt;druid&lt;/artifactId&gt;          &lt;version&gt;1.0.18&lt;/version&gt;&lt;/dependency&gt;\n \n初始化连接在druid连接数据库的配置文件中,读写datasource的bean中 要有 init-method&#x3D;”init”. 配置,否则在启动连接池时不会执行初始化操作。\n示例:\n&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;.......  &lt;/bean&gt;\n\n参数配置及说明通过 spring 配置文件application-context.xml中的dataSource配置说明各个参数的配置。\n\n\n\n属性\n说明\n建议值\n\n\n\nurl\n数据库的jdbc连接地址。一般为连接oracle&#x2F;mysql。示例如下：\n\n\n\n\nmysql : jdbc:mysql:&#x2F;&#x2F;ip:port&#x2F;dbname?option1&amp;option2&amp;…\n\n\n\n\noracle : jdbc:oracle:thin:@ip:port:oracle_sid\n\n\n\n\n\n\n\n\nusername\n登录数据库的用户名\n\n\n\npassword\n登录数据库的用户密码\n\n\n\ninitialSize\n启动程序时，在连接池中初始化多少个连接\n10-50已足够\n\n\nmaxActive\n连接池中最多支持多少个活动会话\n\n\n\nmaxWait\n程序向连接池中请求连接时,超过maxWait的值后，认为本次请求失败，即连接池\n100\n\n\n\n没有可用连接，单位毫秒，设置-1时表示无限等待\n\n\n\nminEvictableIdleTimeMillis\n池中某个连接的空闲时长达到 N 毫秒后, 连接池在下次检查空闲连接时，将\n见说明部分\n\n\n\n回收该连接,要小于防火墙超时设置\n\n\n\n\nnet.netfilter.nf_conntrack_tcp_timeout_established的设置\n\n\n\ntimeBetweenEvictionRunsMillis\n检查空闲连接的频率，单位毫秒, 非正整数时表示不进行检查\n\n\n\nkeepAlive\n程序没有close连接且空闲时长超过 minEvictableIdleTimeMillis,则会执\ntrue\n\n\n\n行validationQuery指定的SQL,以保证该程序连接不会池kill掉,其范围不超\n\n\n\n\n过minIdle指定的连接个数。\n\n\n\nminIdle\n回收空闲连接时，将保证至少有minIdle个连接.\n与initialSize相同\n\n\nremoveAbandoned\n要求程序从池中get到连接后, N 秒后必须close,否则druid 会强制回收该\nfalse,当发现程序有未\n\n\n\n连接,不管该连接中是活动还是空闲, 以防止进程不会进行close而霸占连接。\n正常close连接时设置为true\n\n\nremoveAbandonedTimeout\n设置druid 强制回收连接的时限，当程序从池中get到连接开始算起，超过此\n应大于业务运行最长时间\n\n\n\n值后，druid将强制回收该连接，单位秒。\n\n\n\nlogAbandoned\n当druid强制回收连接后，是否将stack trace 记录到日志中\ntrue\n\n\ntestWhileIdle\n当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效)\ntrue\n\n\nvalidationQuery\n检查池中的连接是否仍可用的 SQL 语句,drui会连接到数据库执行该SQL默认值每种数据库都不相同：Mysql:SELECT 1; SQLSERVER:SELECT 1; ORACLE:SELECT ‘x’ FROM DUAL; PostGresql:SELECT ‘x’;\n\n\n\n\n正常返回，则表示连接可用，否则表示连接不可用\n\n\n\ntestOnBorrow\n程序 申请 连接时,进行连接有效性检查（低效，影响性能）\nfalse\n\n\ntestOnReturn\n程序 返还 连接时,进行连接有效性检查（低效，影响性能）\nfalse\n\n\npoolPreparedStatements\n缓存通过以下两个方法发起的SQL:\ntrue\n\n\n\npublic PreparedStatement prepareStatement(String sql)\n\n\n\n\npublic PreparedStatement prepareStatement(String sql,\n\n\n\n\nint resultSetType, int resultSetConcurrency)\n\n\n\nmaxPoolPrepareStatementPerConnectionSize\n每个连接最多缓存多少个SQL\n20\n\n\nfilters\n这里配置的是插件,常用的插件有:\nstat,wall,slf4j\n\n\n\n监控统计: filter:stat\n\n\n\n\n日志监控: filter:log4j 或者 slf4j\n\n\n\n\n防御SQL注入: filter:wall\n\n\n\nconnectProperties\n连接属性。比如设置一些连接池统计方面的配置。\n\n\n\n\ndruid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;5000\n\n\n\n\n比如设置一些数据库连接属性:\n\n\n\n\n\n\n\n\n注意事项底层连接另外还有一个参数 accessToUnderlyingConnectionAllowed. 该参数设置是否允许使用底层连接。 如果设置为true,可以使用下面的方式来获取底层连接:\nConnection conn = ds.getConnection();Connection dconn = ((DelegatingConnection) conn).getInnermostDelegate();...conn.close();\n\n默认false不开启, 因为代码逻辑不正确，可能会带来风险。建议需要直接访问驱动的特定功能时再使用,并且经过多次测试, 明确代码每一步可能带来的风险。\n\n空闲检查问题在使用阿里的SLB时，建议将timeBetweenEvictionRunsMillis设置为2秒或者负值(关闭检查机制)。否则，连接进程会报:\nCould not open JDBC Connection for transaction; nested exception is com.mysql.jdbc.exceptions.jdbc4.CommunicaiotnsException: Communications link failure\n\n不同配置文件其中 spring boot application.properties 中的配置最为完整，建议参考。\n\njdbc中配置连接池jdbc.properties：jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://172.49.15.55:3306/testdb?useUnicode=true&amp;amp;characterEncoding=utf-8jdbc.username=testjdbc.password=testjdbc.filters=statjdbc.maxActive=300jdbc.initialSize=2jdbc.maxWait=60000jdbc.minIdle=1jdbc.timeBetweenEvictionRunsMillis=60000jdbc.minEvictableIdleTimeMillis=300000jdbc.validationQuery=SELECT &#x27;x&#x27;jdbc.testWhileIdle=truejdbc.testOnBorrow=falsejdbc.testOnReturn=falsejdbc.poolPreparedStatements=falsejdbc.maxPoolPreparedStatementPerConnectionSize=50\n\n\nspring中配置druid&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;      &lt;!-- ”连接“的基本属性  --&gt;      &lt;property name=&quot;url&quot; value=&quot;jdbc_url&quot; /&gt;      &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_user&#125;&quot; /&gt;      &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot; /&gt;      &lt;!-- 连接池属性 --&gt;      &lt;property name=&quot;initialSize&quot; value=&quot;100&quot; /&gt;      &lt;property name=&quot;maxActive&quot; value=&quot;1000&quot; /&gt;      &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt;      &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=300000 /&gt;      &lt;property name=&quot;keepAlive&quot; value=true /&gt;      &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=-1 /&gt;      &lt;property name=&quot;minIdle&quot; value=&quot;20&quot; /&gt;      &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot;/&gt;      &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;180&quot;/&gt;      &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt;      &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;      &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &#x27;x&#x27;&quot; /&gt;      &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt;      &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt;      &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;      &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot;/&gt;      &lt;property name=&quot;filters&quot; value=&quot;stat,wall,slf4j&quot;/&gt;      &lt;property name=&quot;connectionProperties&quot; value=&quot;druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000&quot; /&gt;&lt;/bean&gt;\n\n\nspring boot application.properties配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSource#驱动配置信息spring.datasource.driver-class-name=com.mysql.jdbc.Driver#基本连接信息spring.datasource.username = rootspring.datasource.password = rootspring.datasource.url=jdbc:mysql://192.168.153.23:3306/mytest?useUnicode=true&amp;characterEncoding=utf-8#连接池属性spring.datasource.druid.initial-size=15spring.datasource.druid.max-active=100spring.datasource.druid.min-idle=15spring.datasource.druid.max-wait=60000spring.datasource.druid.time-between-eviction-runs-millis=60000spring.datasource.druid.min-evictable-idle-time-millis=300000spring.datasource.druid.test-on-borrow=falsespring.datasource.druid.test-on-return=falsespring.datasource.druid.test-while-idle=truespring.datasource.druid.validation-query=SELECT 1spring.datasource.druid.validation-query-timeout=1000spring.datasource.druid.keep-alive=truespring.datasource.druid.remove-abandoned=truespring.datasource.druid.remove-abandoned-timeout=180spring.datasource.druid.log-abandoned=truespring.datasource.druid.pool-prepared-statements=truespring.datasource.druid.max-pool-prepared-statement-per-connection-size=20spring.datasource.druid.filters=stat,wall,slf4jspring.datasource.druid.use-global-data-source-stat=truespring.datasource.druid.preparedStatement=truespring.datasource.druid.maxOpenPreparedStatements=100spring.datasource.druid.connect-properties.mergeSql=truespring.datasource.druid.connect-properties.slowSqlMillis=5000\n\n","categories":["数据库"],"tags":["Druid"]},{"title":"FileUtils","url":"/2023/07/24/FileUtils/","content":"public final class FileUtils &#123;    private static final String PREFIX_PATH = StrUtil.format(            &quot;&#123;userDir&#125;&#123;separator&#125;docker&#123;separator&#125;static-file&#123;separator&#125;&quot;,            MapUtil.builder(&quot;userDir&quot;, System.getProperties().get(&quot;user.dir&quot;).toString())                    .put(&quot;separator&quot;, File.separator)                    .build()    );//    private static String PREFIX_PATH = &quot;/docker/static-file/&quot;;    static &#123;        log.info(&quot;初始化文件存放路径: &#123;&#125;&quot;, PREFIX_PATH);    &#125;    /**     * 保存文件     *     * @param file     * @return     */    public static FileOperation save(MultipartFile file) &#123;        String originalFilename = file.getOriginalFilename();        String extName = FileUtil.extName(originalFilename);        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);//        File newFile = new File(PREFIX_PATH + uuid + &quot;.&quot; + extName);        File newFile = new File(PREFIX_PATH + originalFilename);        if (newFile.exists()) &#123;            // 存在重名文件, 则删除            newFile.deleteOnExit();            log.info(&quot;删除重名文件: &quot; + newFile.getAbsolutePath());        &#125;        if (!newFile.getParentFile().exists()) &#123;            // 递归创建文件夹            log.info(&quot;创建上级目录&#123;&#125;&quot;, newFile.getParentFile().getAbsolutePath());            newFile.getParentFile().mkdirs();        &#125;        try &#123;            file.transferTo(newFile);        &#125; catch (IOException e) &#123;            log.warn(&quot;创建&quot; + newFile.getAbsolutePath() + &quot;文件失败: &quot; + e.getMessage(), e);            return FileOperation.error(newFile, e, FileOperation.SAVE);        &#125;        return FileOperation.ok(newFile, FileOperation.SAVE);    &#125;    /**     * 更新文件     *     * @param path     * @param isAbsolute     * @param file     * @return     */    public static FileOperation update(String path, boolean isAbsolute, MultipartFile file) &#123;        File oldFile = new File(isAbsolute ? path : PREFIX_PATH + path);        if (oldFile.exists()) &#123;            log.info(&quot;删除旧文件&#123;&#125;&quot;, oldFile.getAbsolutePath());        &#125;        if (!oldFile.getParentFile().exists()) &#123;            log.info(&quot;创建上级目录&#123;&#125;&quot;, oldFile.getParentFile().getAbsolutePath());            oldFile.mkdirs();        &#125;        try &#123;            file.transferTo(oldFile);        &#125; catch (IOException e) &#123;            log.warn(&quot;更新文件&quot; + oldFile.getAbsolutePath() + &quot;文件失败: &quot; + e.getMessage(), e);            return FileOperation.error(oldFile, e, FileOperation.UPDATE);        &#125;        return FileOperation.ok(oldFile, FileOperation.UPDATE);    &#125;    /**     * 删除文件     *     * @param path     * @param isAbsolute     * @return     */    public static FileOperation delete(String path, boolean isAbsolute) &#123;        File file = new File(isAbsolute ? path : PREFIX_PATH + path);        if (!file.exists()) &#123;            FileOperation error = FileOperation.error(file, new FileNotFoundException(file.getAbsolutePath()), FileOperation.DELETE);            log.warn(&quot;文件&#123;&#125;已被删除&quot;, error.getRelativePath());            return error;        &#125;        file.deleteOnExit();        return FileOperation.ok(file, FileOperation.DELETE);    &#125;    public static class FileOperation &#123;        public static final String SAVE = &quot;save&quot;;        public static final String UPDATE = &quot;update&quot;;        public static final String DELETE = &quot;delete&quot;;        private boolean ok;        private String operation;        private File file;        private String relativePath;        private Throwable cause;        public FileOperation(boolean ok, File file, Throwable cause, String operation) &#123;            this.ok = ok;            this.file = file;            if (file.getAbsolutePath().indexOf(PREFIX_PATH) == 0) &#123;                this.relativePath = file.getAbsolutePath().substring(PREFIX_PATH.length());            &#125;            this.cause = cause;            this.operation = operation;        &#125;        public boolean ok() &#123;            return ok;        &#125;        public String getRelativePath() &#123;            return relativePath;        &#125;        public String getAbsolutePath() &#123;            return file.getAbsolutePath();        &#125;        public Throwable getCause() &#123;            return cause;        &#125;        public static FileOperation ok(File file, String operation) &#123;            return new FileOperation(true, file, null, operation);        &#125;        public static FileOperation error(File file, Throwable cause, String operation) &#123;            return new FileOperation(false, file, cause, operation);        &#125;    &#125;&#125;\n\nWebConfig\n@Componentpublic class WebConfig implements WebMvcConfigurer &#123;\t    //yml中的路径    @Value(value = &quot;$&#123;file.path&#125;&quot;)    private String filePath;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        String PREFIX_PATH = StrUtil.format(                &quot;&#123;userDir&#125;&#123;separator&#125;src&#123;separator&#125;main&#123;separator&#125;resources&#123;separator&#125;static&#123;separator&#125;file&#123;separator&#125;&quot;,                MapUtil.builder(&quot;userDir&quot;, System.getProperties().get(&quot;user.dir&quot;).toString())                        .put(&quot;separator&quot;, File.separator)                        .build()        );        log.info(&quot;资源映射位置: [&#123;&#125;]&quot;, filePath);        registry.addResourceHandler(&quot;/file/**&quot;)                .setCacheControl(CacheControl.noCache())                .addResourceLocations(&quot;file:&quot; + filePath)                .addResourceLocations(&quot;file:&quot; + PREFIX_PATH);    &#125;&#125;\n\n","categories":["SpringBoot"],"tags":["Java"]},{"title":"JsonUtils工具类实现","url":"/2023/07/17/JsonUtils%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AE%9E%E7%8E%B0/","content":"第一种\npublic class JsonUtils &#123;    private static final TypeReference&lt;Map&lt;String, Object&gt;&gt; MAP_TYPE_REFERENCE = new TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;    &#125;;    private static final TypeReference&lt;List&lt;Object&gt;&gt; LIST_TYPE_REFERENCE = new TypeReference&lt;List&lt;Object&gt;&gt;() &#123;    &#125;;    private JsonUtils() &#123;    &#125;    public static String serialize(Object o) throws JsonProcessingException &#123;        ObjectMapper objectMapper = new ObjectMapper();        return objectMapper.writeValueAsString(o);    &#125;    public static &lt;T&gt; T deserializeForClass(String s, Class&lt;T&gt; clazz) throws JsonProcessingException &#123;        ObjectMapper objectMapper = new ObjectMapper();        return objectMapper.readValue(s, clazz);    &#125;    public static Map&lt;String, Object&gt; deserializeForMap(String s) throws JsonProcessingException &#123;        ObjectMapper objectMapper = new ObjectMapper();        return objectMapper.readValue(s, MAP_TYPE_REFERENCE);    &#125;    public static List&lt;Object&gt; deserializeForList(String s) throws JsonProcessingException &#123;        ObjectMapper objectMapper = new ObjectMapper();        return objectMapper.readValue(s, LIST_TYPE_REFERENCE);    &#125;    /**     * 序列化为json字符串     *     * @param o     * @return     */    public static String quietlySerialize(Object o) &#123;        try &#123;            return serialize(o);        &#125; catch (JsonProcessingException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 反序列化为指定类型的对象     *     * @param s     * @param clazz     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; T quietlyDeserializeForClass(String s, Class&lt;T&gt; clazz) &#123;        try &#123;            return deserializeForClass(s, clazz);        &#125; catch (JsonProcessingException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 反序列化为 &#123;@link Map&#125;     *     * @param s     * @return     */    public static Map&lt;String, Object&gt; quietlyDeserializeForMap(String s) &#123;        try &#123;            return deserializeForMap(s);        &#125; catch (JsonProcessingException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 反序列化为 &#123;@link List&#125;     *     * @param s     * @return     */    public static List&lt;Object&gt; quietlyDeserializeForList(String s) &#123;        try &#123;            return deserializeForList(s);        &#125; catch (JsonProcessingException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 美化json字符串     *     * @param json     * @return     */    public static String toPrettyString(String json) &#123;        String prettyString = JSONUtil.toJsonPrettyStr(json);        return prettyString;    &#125;&#125;\n\n第二种\npublic class JsonUtils &#123;    public static final ObjectMapper mapper = new ObjectMapper();    private static final Logger logger = LoggerFactory.getLogger(JsonUtils.class);    /**     * 转为json     *     * @param obj     * @return     */    public static String serialize(Object obj) &#123;        if (obj == null) &#123;            return null;        &#125;        if (obj.getClass() == String.class) &#123;            return (String) obj;        &#125;        try &#123;            return mapper.writeValueAsString(obj);        &#125; catch (JsonProcessingException e) &#123;            logger.error(&quot;json序列化出错：&quot; + obj, e);            return null;        &#125;    &#125;    /**     * JSON转POJO     *     * @param json     * @param tClass     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; T parse(String json, Class&lt;T&gt; tClass) &#123;        try &#123;            return mapper.readValue(json, tClass);        &#125; catch (IOException e) &#123;            logger.error(&quot;json解析出错：&quot; + json, e);            return null;        &#125;    &#125;    /**     * JSON数组转List     *     * @param json     * @param eClass     * @param &lt;E&gt;     * @return     */    public static &lt;E&gt; List&lt;E&gt; parseList(String json, Class&lt;E&gt; eClass) &#123;        try &#123;            return mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, eClass));        &#125; catch (IOException e) &#123;            logger.error(&quot;json解析出错：&quot; + json, e);            return null;        &#125;    &#125;    /**     * Json、Json数组转Map     *     * @param json     * @param kClass     * @param vClass     * @param &lt;K&gt;     * @param &lt;V&gt;     * @return     */    public static &lt;K, V&gt; Map&lt;K, V&gt; parseMap(String json, Class&lt;K&gt; kClass, Class&lt;V&gt; vClass) &#123;        try &#123;            return mapper.readValue(json, mapper.getTypeFactory().constructMapType(Map.class, kClass, vClass));        &#125; catch (IOException e) &#123;            logger.error(&quot;json解析出错：&quot; + json, e);            return null;        &#125;    &#125;    /**     * 万能转换     * @param json     * @param type     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; T nativeRead(String json, TypeReference&lt;T&gt; type) &#123;        try &#123;            return mapper.readValue(json, type);        &#125; catch (IOException e) &#123;            logger.error(&quot;json解析出错：&quot; + json, e);            return null;        &#125;    &#125;&#125;\n\n","categories":["SpringBoot"],"tags":["Java"]},{"title":"MySQL 安装","url":"/2023/05/21/MySQL-%E5%AE%89%E8%A3%85/","content":"所有平台的 MySQL 下载地址为： MySQL 下载 。 挑选你需要的 MySQL Community Server 版本及对应的平台。\n\n注意：安装过程我们需要通过开启管理员权限来安装，否则会由于权限不足导致无法安装。\n\n\n \nLinux&#x2F;UNIX 上安装 MySQLLinux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址：\n\nMySQL - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。\nMySQL-client - MySQL 客户端程序，用于连接并操作Mysql服务器。\nMySQL-devel - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。\nMySQL-shared - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。\nMySQL-bench - MySQL数据库服务器的基准和性能测试工具。\n\n安装前，我们可以检测系统是否自带安装 MySQL:\nrpm -qa | grep mysql\n\n如果你系统有安装，那可以选择进行卸载:\nrpm -e mysql　　// 普通删除模式rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除\n\n安装 MySQL：\n接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/\n\nwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum updateyum install mysql-server\n\n权限设置：\nchown -R mysql:mysql /var/lib/mysql/\n\n初始化 MySQL：\nmysqld --initialize\n\n启动 MySQL：\nsystemctl start mysqld\n\n查看 MySQL 运行状态：\nsystemctl status mysqld\n\n注意：如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。\n\n此外,你也可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。\nMariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。\nyum install mariadb-server mariadb \n\nmariadb数据库的相关命令是：\nsystemctl start mariadb  #启动MariaDBsystemctl stop mariadb  #停止MariaDBsystemctl restart mariadb  #重启MariaDBsystemctl enable mariadb  #设置开机启动\n\n\n验证 MySQL 安装在成功安装 MySQL 后，一些基础表会表初始化，在服务器启动后，你可以通过简单的测试来验证 MySQL 是否工作正常。\n使用 mysqladmin 工具来获取服务器状态：\n使用 mysqladmin 命令来检查服务器的版本, 在 linux 上该二进制文件位于 &#x2F;usr&#x2F;bin 目录，在 Windows 上该二进制文件位于C:\\mysql\\bin 。\n[root@host]# mysqladmin --version\n\nlinux上该命令将输出以下结果，该结果基于你的系统信息：\nmysqladmin  Ver 8.23 Distrib 5.0.9-0, for redhat-linux-gnu on i386\n\n如果以上命令执行后未输出任何信息，说明你的Mysql未安装成功。\n\n使用 MySQL Client(Mysql客户端) 执行简单的SQL命令你可以在 MySQL Client(Mysql客户端) 使用 mysql 命令连接到 MySQL 服务器上，默认情况下 MySQL 服务器的登录密码为空，所以本实例不需要输入密码。\n命令如下：\n[root@host]# mysql\n\n以上命令执行后会输出 mysql&gt;提示符，这说明你已经成功连接到Mysql服务器上，你可以在 mysql&gt; 提示符执行SQL命令：\nmysql&gt; SHOW DATABASES;+----------+| Database |+----------+| mysql    || test     |+----------+2 rows in set (0.13 sec)\n\n\nMysql安装后需要做的Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码：\n[root@host]# mysqladmin -u root password &quot;new_password&quot;;\n\n现在你可以通过以下命令来连接到Mysql服务器：\n[root@host]# mysql -u root -pEnter password:*******\n\n注意：在输入密码时，密码是不会显示了，你正确输入即可。\n\nWindows 上安装 MySQLWindows 上安装 MySQL 相对来说会较为简单，最新版本可以在 MySQL 下载 中下载中查看(更详细安装：Windows 上安装 MySQL)。\n\n\n点击 \nDownload\n 按钮进入下载页面，点击下图中的 \nNo thanks, just start my download.\n 就可立即下载：\n\n下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 C:\\web\\mysql-8.0.11 下。\n接下来我们需要配置下 MySQL 的配置文件\n打开刚刚解压的文件夹 C:\\web\\mysql-8.0.11 ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：\n[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB\n\n接下来我们来启动下 MySQL 数据库：\n以管理员身份打开 cmd 命令行工具，切换目录：\ncd C:\\web\\mysql-8.0.11\\bin\n\n初始化数据库：\nmysqld --initialize --console\n\n执行完成后，会输出 root 用户的初始默认密码，如：\n...2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws&amp;hjQ...\n\nAPWCY5ws&amp;hjQ 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。\n输入以下安装命令：\nmysqld install\n\n启动输入以下命令即可：\nnet start mysql\n\n\n注意: 在 5.7 需要初始化 data 目录：\ncd C:\\web\\mysql-8.0.11\\bin mysqld --initialize-insecure \n\n初始化后再运行 net start mysql 即可启动 mysql。\n\n\n登录 MySQL当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:\nmysql -h 主机名 -u 用户名 -p\n\n参数说明：\n\n-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;\n-u : 登录的用户名;\n-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。\n\n如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：\nmysql -u root -p\n\n按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:\nEnter password:\n\n若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor… 的提示语。\n然后命令提示符会一直以 mysql&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。\n配置MySQL执行日志（重启mysql服务后生效）log-output=FILEgeneral-log=1general_log_file=&quot;D:\\mysql.log&quot;slow-query-log=1slow_query_log_file=&quot;D:\\mysql_slow.log&quot;long_query_time=2\n\nPreparedStatement预编译功能开启:useServerPrepStmts=true\n\n","categories":["数据库"],"tags":["mysql"]},{"title":"MySQL配置远程连接","url":"/2023/05/21/MySQL%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","content":"mysql在安装好之后默认是不支持远程连接的，需要用localhost和127.0.0.1才能进行连接，需要进行手动设置才能进行远程连接。\n不设置数据库远程连接，在进行远程连接的时候会报错\n\n\n查看mysql库下的user表可以查看是否可以进行远程连接\n表中host和user字段标识了可以访问数据库的主机和用户，表中数据表示只能本地主机通过root用户访问数据库，所以不能进行远程连接。\n设置远程连接有以下两种方法\n1、改表法\n可以修改user表中host的值，将localhost修改成需要远程连接数据库的主机的ip地址，或者修改成%，修改成%表示所有主机都可以通过root用户访问数据库。\n 执行完修改的sql语句后，需要执行flush privileges命令。\n2、授权法\n语法格式：\ngrant 权限 on 数据库对象 to 用户@ip\ngrant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;szw@123&#x27; with grant option;\n\n\n上面授权的sql适用于mysql8以前的版本\nmysql8已经建创建用户与赋予权限的操作分开，需要先创建用户，然后再进行授权\n","categories":["数据库"],"tags":["mysql"]},{"title":"OPENWRT编译之UA2F","url":"/2023/05/21/OPENWRT%E7%BC%96%E8%AF%91%E4%B9%8BUA2F/","content":"在阅读这一篇之前，请确保你已经掌握了基本的编译方法和要领，也确保自己已经处于全局魔法的环境下。如果你还不懂如何编译，请阅读这篇文章。\n温馨提示：\nBefore continuing to read this article, I hope that you have made sure that the automatic translation feature in your own browser (chrome explorer) has been turned off, as this feature can lead to some misleading and biased tutorial content, thank you.\n\n开始编译\n在编译之前，请先更新确保自己的固件处于最新的状态打开终端，输入命令\n# 系统更新sudo apt-get updatesudo apt-get upgrade\n\n运行完成后，输入命令\n# 安装依赖关系sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync\n\n22.04\nsudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev zlib1g-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc-s1 libc6-dev-i386 subversion flex uglifyjs git gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx-ucl libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync\n\n然后进行下一步，输入命令\n# 下载源码git clone https://github.com/coolsnowwolf/lede.git\n\n接下来进行更新软件源，输入命令\ncd lede# 更新feeds软件源./scripts/feeds update -a# 安装feeds软件包./scripts/feeds install -a\n\n开始编译UA2F\n我们需要将lede/package/libs/libnetfilter-queue 改为openwrt官方版本，网址为： https://github.com/openwrt/packages/tree/master/libs/libnetfilter-queue\n在这一步中，我收到过很多人失败的情况，他们都是用命令进行更换的，所以在这里我个人推荐自己手动更换会最为保险。\n1.直接根据目录的方向将libnetfilter-queue文件夹删除。2.去上面的网址通过这里下载下来，通过winscp，百度云，邮箱等方式放回去原目录替换即可。（百度上有很多github下载的网站，随便一搜就可以了。）\n也可以直接尝试输入svn checkout https://github.com/openwrt/packages/trunk/libs/libnetfilter-queue package/libs/libnetfilter-queue\n完成上一步以后就可以开始进入终端输入命令编译了，输入命令\ncd lede/packagegit clone https://github.com/Zxilly/UA2F.git package/UA2F\n\n然后返回lede目录，输入命令 make menuconfig,进入编译菜单\n我们进去第一件事就是选好我们自己的路由器型号，然后我们需要选一些依赖包来保证UA2F的正常运行。我们需要选libmnl, libnetfilter-queue, iptables-mod-nfqueue这三个依赖包。（我们可以按键盘里的&#x2F;键来搜索关键词找到这些依赖包的位置）\n最后我们在Network - Routing and Redirection里找到ua2f，并按Y选中它。\n随后，对于GuangDong University of Finance的伙伴来说，就已经足够了\n按esc退出菜单\n输入命令make download V=s（这个命令我建议运行2-3次确保无问题）\n随后输入命令make -j12 kernel_menuconfig（j几自己判断）\n第一次编译会有点长，请耐心等待，过一会会弹出一个框框需要我们选择。\n弹出来后，我们在菜单寻找\nNetworking support -&gt; Networking options -&gt;Network packet filtering framework (Netfilter) -&gt;Core Netfilter Configuration -&gt;NFQUEUE and NFLOG integration with Connection Tracking\n\n（按顺序选择，要选中的要按Y的就按，不需要的就不用）注意：这里要在Core Netfilter Configuration把下面这些选了之后才会出现那个tracking\n-*- Netfilter NFNETLINK interface                                                                                                                &lt;*&gt; Netfilter LOG over NFNETLINK interfacer ip_tables)                                                                                           &lt;*&gt; Netfilter connection tracking support &lt;*&gt; Connection tracking netlink interface\n\n当我们都确保选上以后，我们就按保存退出。\n随后输入命令，make -j12 V=s\n然后就可以慢慢等咯。。。。。。\n完成这一步以后，可以说编译已经完成了，我们需要将刷好的固件刷进我们的路由器中。\n并用ssh的连接方式输入命令ua2f，查看自己有无装好ua2f。ssh的方法可以用cmd的ssh root@192.168.1.1（ip自己看着办），最好用Xshell来输入。\n如果输入命令后，显示的是not support，则说明没有装成功，需要重新编译。\n如果我们确定自己的ua2f已经装好了，就可以进入路由器后台找到系统-启动项，往下滑到最低找到本地启动脚本输入命令ipset create nohttp hash:ip,port hashsize 16384 timeout 300注意：请确保将此命令输入在exit 0前面。\n随后进入网络-防火墙-自定义规则输入以下命令\niptables -t mangle -N ua2f#由于本校局域网是A类网，所以我将这一条注释掉了，具体要不要注释结合你所在得校园网#iptables -t mangle -A ua2f -d 10.0.0.0/8 -j RETURNiptables -t mangle -A ua2f -d 127.0.0.0/8 -j RETURNiptables -t mangle -A ua2f -d 192.168.0.0/16 -j RETURN # 不处理流向保留地址的包iptables -t mangle -A ua2f -p tcp --dport 443 -j RETURNiptables -t mangle -A ua2f -p tcp --dport 22 -j RETURN # 不处理 SSH 和 httpsiptables -t mangle -A ua2f -p tcp --dport 80 -j CONNMARK --set-mark 24iptables -t mangle -A ua2f -m set --set nohttp dst,dst -j RETURNiptables -t mangle -A ua2f -m connmark --mark 23 -j RETURN # 不处理标记为非 http 的流 (实验性)iptables -t mangle -A ua2f -j NFQUEUE --queue-num 10010 iptables -t mangle -A FORWARD -p tcp -m conntrack --ctdir ORIGINAL -j ua2fiptables -t mangle -A FORWARD -p tcp -m conntrack --ctdir REPLY\n\n注意：由于GuangDong University of Finance 的校园局域网是A类网，所以需要注释iptables -t mangle -A ua2f -d 10.0.0.0/8 -j RETURN接下来，我们只需要用ssh输入命令service ua2f start,即可成功启动ua2f。\n至此，ua2f的编译工作已经基本结束。\n查看效果\n打开http://ua.zhezhiyu.xyz/，来验证自己的ua。\n后台输出\nSat Mar 13 15:23:09 2021 syslog.info UA2F[1516]: UA2F has handled 512 http, 0 noua http, 15654 tcp, 134 mark and 39 nohttp mark in 19 hours, 36 minutes and 19 secondsSat Mar 13 16:05:19 2021 syslog.info UA2F[1516]: UA2F has handled 1024 http, 29 noua http, 98264 tcp, 592 mark and 457 nohttp mark in 20 hours, 18 minutes and 29 secondsSat Mar 13 17:28:49 2021 syslog.info UA2F[1516]: UA2F has handled 2048 http, 1505 noua http, 173784 tcp, 1524 mark and 1265 nohttp mark in 21 hours, 41 minutes and 59 secondsSat Mar 13 18:49:10 2021 syslog.info UA2F[1516]: UA2F has handled 4096 http, 2782 noua http, 444805 tcp, 3162 mark and 1723 nohttp mark in 23 hours, 2 minutes and 20 seconds\n\n\n\n注意事项补充安装\nsudo apt-get install manpages-pl manpages-fr-extra\n\n如果是64位系统的话还需要安装32位兼容包\nsudo apt-get install libc6:i386 libgcc1:i386 libstdc++5:i386 libstdc++6:i386\n\n安装ARM-Linux-GCC工具链\n只需要一句命令：\nsudo apt-get install gcc-arm-linux-gnueabi\n\n将toolchain加到PATH里面\nexport STAGING_DIR=/home/xue/lede/staging_dir/toolchain-mips_24kc_gcc-8.4.0_musl/bin/export PATH=$STAGING_DIR/:$PATH\n\n\nsvn更新了源码\n\n源码动了工具链，老的代码导致连接失败\n\n清理工具链编译\n根据package的规律，这里用清理来看看运气如何\n\nmake toolchain/clean V=99 -j\n\n大约几秒后清理完毕\n\n再次重新编译，这里用的都是全速的\n\n\nmake toolchain/compile V=99 -j\n\nmake clean &amp;&amp; make dirclean\n\n","categories":["路由器"],"tags":["openwrt"]},{"title":"SimpleDateFormat 格式化时间用法","url":"/2023/05/21/SimpleDateFormat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E7%94%A8%E6%B3%95%EF%BC%9A/","content":"&#x2F;** G 年代标志符 y 年 M 月 d 日 h 时 在上午或下午 (112) H 时 在一天中 (023) m 分 s 秒 S 毫秒 E 星期 D 一年中的第几天 F 一月中第几个星期几 w 一年中第几个星期 W 一月中第几个星期 a 上午 &#x2F; 下午 标记符 k 时 在一天中 (124) K 时 在上午或下午 (011) z 时区 *&#x2F;\nft.setTimeZone(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));// 设置时区","categories":["Java"],"tags":["Java"]},{"title":"Test工具类","url":"/2023/07/24/Test%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"BasicMockRequest\npublic interface BasicMockRequest &#123;    /**     * 发送get请求     *     * @param uri     * @return     */    default RequestBuilder get(String uri) &#123;        return MockMvcRequestBuilders.get(uri)                .accept(MediaType.APPLICATION_JSON_UTF8);    &#125;    /**     * 发送get请求并携带token     *     * @param uri     * @param token     * @return     */    default RequestBuilder getAndTakeToken(String uri, String token) &#123;        return MockMvcRequestBuilders.get(uri)                .header(&quot;token&quot;, token)                .accept(MediaType.APPLICATION_JSON_UTF8);    &#125;    /**     * 发送post请求     *     * @param uri     * @return     */    default RequestBuilder post(String uri) &#123;        return MockMvcRequestBuilders.post(uri)                .accept(MediaType.APPLICATION_JSON_UTF8);    &#125;    /**     * 发送post请求并携带token和请求体     *     * @param uri     * @param token     * @param data     * @return     */    default RequestBuilder postAndTakeTokenAndData(String uri, String token, Object data) &#123;        String content = Optional.ofNullable(data)                .map(JsonUtils::quietlySerialize)                .orElse(&quot;&quot;);        return MockMvcRequestBuilders.post(uri)                .header(&quot;token&quot;, token)                .accept(MediaType.APPLICATION_JSON_UTF8)                .contentType(MediaType.APPLICATION_JSON_UTF8)                .content(content);    &#125;    /**     * 发送post请求并携带请求参数     *     * @param uri     * @param data     * @return     */    default RequestBuilder postAndTakeRequestParameter(String uri, Object data) &#123;        MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.post(uri)                .accept(MediaType.APPLICATION_JSON_UTF8);        Map&lt;String, String&gt; parameterMap = ObjectAttribute.toParameterMap(data);        parameterMap.forEach((k, v) -&gt; requestBuilder.param(k, v));        return requestBuilder;    &#125;    /**     * 发送post请求并携带token和请求参数     *     * @param uri     * @param token     * @param data     * @return     */    default RequestBuilder postAndTokenAndRequestParameter(String uri, String token, Object data) &#123;        return ((MockHttpServletRequestBuilder) postAndTakeRequestParameter(uri, data))                .header(&quot;token&quot;, token);    &#125;    /**     * 发送post请求并携带请求体     *     * @param uri     * @param data     * @return     */    default RequestBuilder postAndTakeRequestBody(String uri, Object data) &#123;        return MockMvcRequestBuilders.post(uri)                .accept(MediaType.APPLICATION_JSON_UTF8)                .contentType(MediaType.APPLICATION_JSON_UTF8)                .content(JsonUtils.quietlySerialize(data));    &#125;&#125;\n\nMockContext\npublic interface MockContext &#123;    /**     * 获取测试用户     *     * @return     */    User getMockUser();    /**     * 获取测试token     *     * @return     */    String getMockToken();    /**     * 获取测试url     *     * @return     */    String getBaseUrl();    /**     * 获取测试的mvc环境     *     * @return     */    MockMvc getMockMvc();&#125;\n\nMockContextImpl\n@Component@DependsOn(&quot;tokenUtils&quot;)@ConditionalOnProperty(value = &quot;enroll.mock&quot;, havingValue = &quot;true&quot;)public class MockContextImpl implements MockContext &#123;    private static final Logger log = LoggerFactory.getLogger(MockContextImpl.class);    /**     * 测试用的token（有效期：永久）     */    private String mockToken;    private User mockUser;    private MockMvc mockMvc;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String port;    private String baseUrl = &quot;http://localhost:%s/api&quot;;    @Autowired    private UserDao userDao;    @Autowired    private TokenDao tokenDao;    @Autowired    private ProcessService processService;    @Autowired    private ProcessDao processDao;    @Autowired    private WebApplicationContext webApplicationContext;    @Override    public User getMockUser() &#123;        return mockUser;    &#125;    @Override    public String getMockToken() &#123;        return mockToken;    &#125;    @Override    public String getBaseUrl() &#123;        return baseUrl;    &#125;    @Override    public MockMvc getMockMvc() &#123;        return mockMvc;    &#125;    @PostConstruct    public void initialization() &#123;        mockUser = createMockUserAndInsertToDatabase();        mockToken = createMockTokenAndInsertToDatabase();        baseUrl = String.format(baseUrl, port);        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)                .alwaysDo(MockMvcResultHandlers.print())                .build();        log.info(&quot;initialization mock user: &#123;&#125; success&quot;, mockUser.getId());        log.info(&quot;initialization mock token: &#123;&#125; success&quot;, mockToken);        log.info(&quot;initialization baseUrl: &#123;&#125; success&quot;, baseUrl);        log.info(&quot;initialization mock web environment success&quot;);    &#125;    private String createMockTokenAndInsertToDatabase() &#123;        // 世界人均寿命: 71岁 --- 2021/09/23        final long year = 365L;        long hundredYearLater = System.currentTimeMillis() + Duration.ofDays(year * 100L).toMillis();        Date permanent = new Date(hundredYearLater);        log.info(&quot;hundredYearLater: &#123;&#125;&quot;, DateUtil.format(permanent, &quot;yyyy/MM/dd HH:mm:ss&quot;));        Token token = TokenUtils.createTokenAndSpecifyExpirationTime(mockUser.getId(), permanent);        tokenDao.insertSelective(token);        return token.getToken();    &#125;    private User createMockUserAndInsertToDatabase() &#123;        Date createTime = new Date();        String randomOpenId = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);        User user = new User();        user.setOpenId(randomOpenId);        user.setStatus(UserStatusEnum.REGISTERED.getStatus());        user.setAuthority(AuthorityEnum.PROGRAMMING_DEPARTMENT_ADMINISTRATOR.getAuthority());        user.setTerm(SystemConstant.TERM);        user.setCreateTime(createTime);        user.setUpdateTime(createTime);        userDao.insertSelective(user);        processService.initialUserProcess(user.getId());        return user;    &#125;    /**     * 删除测试用户和测试token     */    @PreDestroy    public void destroy() &#123;        deleteMockUserIfExists();        deleteMockTokenIfExists();    &#125;    private void deleteMockUserIfExists() &#123;        Optional.ofNullable(mockUser)                .ifPresent(user -&gt; &#123;                    userDao.deleteByPrimaryKey(user.getId());                    processDao.deleteByUserId(user.getId());                    log.info(&quot;删除mock user: &#123;&#125; 成功&quot;, user.getId());                &#125;);    &#125;    private void deleteMockTokenIfExists() &#123;        Optional.ofNullable(mockToken)                .ifPresent(token -&gt; &#123;                    tokenDao.deleteByToken(token);                    log.info(&quot;删除mock token: &#123;&#125; 成功&quot;, token);                &#125;);    &#125;&#125;\n\nObjectAttribute\npublic class ObjectAttribute &#123;    private static final int getStringLength = 3;    private String attributeName;    private Object attributeValue;    public ObjectAttribute(Object target, Method method) &#123;        String unmodifiedAttributeName = method.getName().substring(getStringLength);        if (unmodifiedAttributeName.isEmpty()) &#123;            throw new IllegalArgumentException(&quot;getter方法名称错误: &quot; + method.getName());        &#125;        // 首字母转小写        attributeName = Character.toLowerCase(unmodifiedAttributeName.charAt(0)) + unmodifiedAttributeName.substring(1);        try &#123;            attributeValue = method.invoke(target);        &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;            throw new RuntimeException(&quot;getter方法必须为无参方法&quot;, e);        &#125;    &#125;    public String getAttributeName() &#123;        return attributeName;    &#125;    public Object getAttributeValue() &#123;        return attributeValue;    &#125;    public static Map&lt;String, String&gt; toParameterMap(Object data) &#123;        if (data == null) &#123;            return Collections.emptyMap();        &#125;        Map&lt;String, String&gt; objectAttributeMap = Arrays.stream(data.getClass().getDeclaredMethods())                .filter(method -&gt; method.getName().startsWith(&quot;get&quot;))                .map(method -&gt; new ObjectAttribute(data, method))                .collect(Collectors.toMap(ObjectAttribute::getAttributeName, ObjectAttribute::toRequestParam));        return objectAttributeMap;    &#125;    public String toRequestParam() &#123;        return javaDataToRequestQueryParam(attributeValue);    &#125;    private static String javaDataToRequestQueryParam(Object value) &#123;        if (value == null) &#123;            return null;        &#125;        if (value instanceof String) &#123;            return (String) value;        &#125; else if (value instanceof Number) &#123;            return value.toString();        &#125; else if (value instanceof List) &#123;            return JsonUtils.quietlySerialize(value);        &#125; else if (value instanceof Map) &#123;            return JsonUtils.quietlySerialize(value);        &#125; else if (value.getClass().isArray()) &#123;            return JsonUtils.quietlySerialize(value);        &#125; else if (value instanceof Date) &#123;            return DateUtil.format((Date) value, &quot;yyyy/MM/dd HH:mm:ss&quot;);        &#125;        throw new RuntimeException(&quot;无法识别的类型: &quot; + value.getClass().getName());    &#125;&#125;\n\nPrintPrettyJsonResultHandler\npublic class PrintPrettyJsonResultHandler implements ResultHandler &#123;    private static final Logger log = LoggerFactory.getLogger(PrintPrettyJsonResultHandler.class);    @Override    public void handle(MvcResult mvcResult) throws Exception &#123;        MockHttpServletResponse response = mvcResult.getResponse();        response.setCharacterEncoding(&quot;UTF-8&quot;);        String content = response.getContentAsString();        String prettyString = JsonUtils.toPrettyString(content);        log.info(&quot;\\n&#123;&#125;\\n&quot;, prettyString);    &#125;&#125;\n\n","categories":["SpringBoot"],"tags":["Java"]},{"title":"VirtualBox 安装 Arch Linux: 从新建虚拟机到图形界面","url":"/2023/05/21/VirtualBox-%E5%AE%89%E8%A3%85-Arch-Linux-%E4%BB%8E%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B0%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","content":"来源：https://zhuanlan.zhihu.com/p/355826301\n一、下载 Arch Linux 镜像镜像文件，扩展名为 .iso，包含了安装系统所需要的文件。访问以下链接（这是清华大学的开源软件镜像站，国内下载速度更快），下载以「.iso」结尾的文件：\nIndex of &#x2F;archlinux&#x2F;iso&#x2F;latest&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinux&#x2F;iso&#x2F;latest&#x2F;\n二、安装 VirtualBoxVirtualBox 是由 Oracle 公司开发的免费虚拟机软件。访问以下链接，根据你的宿主（即你所使用的物理意义上的、「真实的」电脑）操作系统下载安装包：\nDownloads - Oracle VM VirtualBoxwww.virtualbox.org/wiki/Downloads\n下载虚拟机软件安装包\n安装好后打开应看到形如以下的界面：\n我这已经存在一台虚拟机\n三、新建虚拟机点击「新建」；尽量不要在虚拟机的名称中加入空格，可以使用 arch, archlinux 或 arch_linux 之类的；\n新建虚拟机\n根据宿主内存大小和需求设置内存大小，这里选 2048 MB；\n调整内存\n下面两步按照默认走；\n\n\n这里建议选择「固定大小」；\n\n这里就按照默认的 8 GB，可以按照需求和宿主机磁盘空间自行调整；\n\n等待片刻；\n\n到这一步就新建好了。我们在启动前把显存拉满，保证体验；点击「设置」；进入「显示」，如图把显存拉到 128 MB；\n\n点击「OK」应用设置，这时我们可以启动了。\n四、启动虚拟机点击「启动」；因为没有启动设备，VirtualBox 会让你选择启动设备；\n\n点击\n\n选择先前下载的镜像文件，进入以下界面；\n\n直接按回车，等待片刻，进入以下界面；\n\n五、为安装做准备我们先确认网络连接。执行\nip link\n\n然后\nping baidu.com\n\n如果我们能看到数据正常获取（如下图），就可以 Ctrl + C 结束连接，看到「0% packet loss」就行；\n\n之前提到了清华开源软件源，我们在装系统的过程中也要装不少软件，为了保证速度可以先在系统配置文件中加入清华源：\nvim /etc/pacman.d/mirrorlist\n\n按 i 进入插入模式，然后加入这么几行字：\n## ChinaServer = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch\n\n\n之后按 Esc，然后输入\n:wq\n\n后按回车，即保存并退出 Vim 编辑器。执行\npacman -Syy\n\n更新缓存。\n我们需要确保准确的系统时间：\ntimedatectl set-ntp true\n\n然后可以执行\ntimedatectl status\n\n检查状态，如果像下图这样就没问题了。\n\n现在开始准备磁盘。执行\nfdisk -l\n\n查看磁盘状态。\n\n「loop0」结尾的可以忽略，一般来说只用考虑 &#x2F;dev&#x2F;sda。在这个块设备上新建一个分区：\nfdisk /dev/sda\n\n\n在 Command 后执行\nn\n\n来新建分区，然后按照默认（default）配置，一路回车，直到 Command 再次出现，\n\n这时执行\nw\n\n退出分区设置。此时再次执行\nfdisk -l\n\n可以看到新的分区为 &#x2F;dev&#x2F;sda1\n\n这时执行\nmkfs.ext4 /dev/sda1\n\n来格式化分区，然后执行\nmount /dev/sda1 /mnt\n\n来挂载分区。\n\n六、安装执行\npacstrap /mnt base linux linux-firmware\n\n来安装 base 软件包、Linux 内核和固件。这一步会花费较多时间，耐心等待即可，保证网络连接的稳定。\n正在安装各种软件包……\n结束后执行\ngenfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n\n来生成 fstab 文件。这个文件规定了文件系统之间的挂载。之后执行\narch-chroot /mnt\n\n进入安装好的系统。\n\n七、配置系统设置时区：\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n和\nhwclock --systohc\n\n之后进行本地化，以明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准。由于设置中文本地化会出现乱码，我们首先设置 en_GB（英国英语）。先安装 Vim 文本编辑器：\npacman -S vim\n\n需要确认继续时按 y 后回车；\n\n然后用 Vim 打开 &#x2F;etc&#x2F;locale.gen：\nvim /etc/locale.gen\n\n和之前一样，按 i 进入插入模式，找到\n#en_GB.UTF-8 UTF-8\n\n这一行，把前面的「#」去掉，然后按 Esc，执行\n:wq\n\n保存并退出。之后：\nvim /etc/locale.conf\n\n在这个文件中加入\nLANG=en_GB.UTF-8\n\n这一行字，然后保存退出。编辑完两个文件之后：\nlocale-gen\n\n看到 Generation complete 即说明本地化生成完成。\n\n这时可以执行\npasswd\n\n来设置 root （即管理员用户）的密码，需要输入两次以确认（输的时候不会明文显示出来）。\n\n接下来，关键的一步，安装 dhcpcd：\npacman -S dhcpcd\n\n否则重启后无法连接到网络。\n\n配置的最后一步，安装系统引导程序 grub：\npacman -S grub\n\n和\ngrub-install /dev/sda\n\n以及\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n\n这样我们的系统就配置好了，此时重启。执行\nexit\n\n来退出 chroot，然后执行\npoweroff\n\n来关机，虚拟机窗口随后关闭。\n八、第一次启动 Arch Linux再次启动前，进入虚拟机的「设置」&#x3D;&gt;「存储」，如图移除用以安装的虚拟盘，点击「OK」应用设置。\n\n然后点击「启动」，进入 grub\n\n按回车启动 Arch Linux，进入系统，输入 root（用户名）和密码（先前设置的）；\n\n执行\nsystemctl enable dhcpcd\n\n和\ndhcpcd\n\n启用网络连接，\n\n之后用第五步中的方法测试网络。\n一个基本的 Arch Linux 的安装至此结束。\n九、安装后配置root 用户的权限过高，造成对系统灾难性的损坏的风险因此较高，我们因此新建一个用户：\nuseradd -m -G wheel username\n\n将其中的 username 改为你要的名字，比如\nuseradd -m -G wheel jiewei\n\n执行\npasswd username\n\n来设置密码，与先前设置 root 密码一样。\n不使用 root 时如何获得 root 权限呢？需要在命令前加上 sudo，而 sudo 也需要先安装：\npacman -S sudo\n\n之后来配置 sudo 使所有用户都能使用；执行\nln -s /usr/bin/vim /usr/bin/vi\n\n和\nvisudo\n\n进入 Vim 编辑器，找到\n# %wheel ALL=(ALL) ALL\n\n一行，把「#」去掉，保存退出。\n配置好之后执行\nreboot\n\n来重启。重启之后我们就可以使用新创建的用户；输入用户名和密码，进入系统。\n\n十、图形界面没有图形界面的系统对于大多数人还是陌生的，在安装图形界面之前，我们需要安装显卡驱动：\nsudo pacman -S xf86-video-intel\n\nsudo 命令一段时间内需要输入密码确认，注意是用户密码而非 root 密码。\n接下来安装开源窗口系统服务 Xorg：\nsudo pacman -S xorg\n\n然后按回车走默认（即安装所有需要安装的）。之后安装桌面环境 Xfce：\nsudo pacman -S xfce4 xfce4-goodies\n\n也是按回车走默认。最后安装桌面管理器 sddm：\nsudo pacman -S sddm\n\n然后设置开机启动：\nsudo systemctl enable sddm\n\n最后需要安装管理网络连接的程序 network-manager-applet：\nsudo pacman -S network-manager-applet\n\n重启：\nreboot\n\n之后就能看到熟悉而友好的图形界面了。\n图形界面！（我们可以进入 Settings &#x3D;&amp;amp;amp;amp;amp;amp;gt; Display 调整分辨率）\n这时我们需要重新配置网络。输入密码进入系统后打开终端\n图标长这样，就在 Dock（任务栏）里\n然后启用 NetworkManager（桌面环境使用的网络服务）：\nsudo systemctl enable NetworkManager\n\n然后重启，成功联网。\n\n之后配置声音；执行以下命令：\nsudo pacman -S pavucontrol pulseaudiopulseaudio --checkpulseaudio -D\n\n这样就能播放音频了。\n十一、有用的软件包及本地化目前用的文本编辑器都是命令行工具 Vim，比起 gedit 这一图形界面工具来说显得不怎么友好：\nsudo pacman -S gedit\n\n我们可以给 pacman 添加中文社区仓库。用新装的 gedit 打开 &#x2F;etc&#x2F;pacman.conf：\nsudo gedit /etc/pacman.conf\n\n然后在末尾添加两行：\n[archlinuxcn]Server = https://repo.archlinuxcn.org/$arch\n\n之后更新缓存：\nsudo pacman -Sy\n\n目前我们都使用 pacman 安装软件，而另一个工具 yay 则可以用来安装 AUR（Arch User Repository，Arch 用户库）中的大量软件。先安装需要用到的 git 和 base-devel：\nsudo pacman -S git base-devel\n\n然后：\ngit clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si\n\n我们大概还需要一个浏览器，安装火狐是最方便的：\nsudo pacman -S firefox\n\n这样点击 Dock 中的地球图标就能上网了。打开网页，发现中文内容是乱码；\n\n我们需要安装中文字体：\nsudo pacman -S noto-fonts-cjk\n\n\n这下是大家都看得懂的中文字了。\n我们还需要安装中文输入法，使用 fcitx 框架：\nsudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-sunpinyin\n\n设置环境变量：\nsudo gedit ~/.xprofile\n\n在编辑器中加入\nexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;\n\n然后执行：\nfcitx-configtool\n\n如下图所示，点击「+」，然后取消勾选「Only Show Current Language」，找到安装的「Sunpinyin」，点击「OK」。（如果没有出现这些可能需要重启）\n\n重启后中文输入法便出现了。\n\n十二、真正开始使用对于 Windows 或 macOS 用户来说，「自由软件」这一概念大概是陌生的。事实上，如 Microsoft Office 和 Adobe Photoshop 这样的商业软件几乎都有它们的自由软件替代品（比如 LibreOffice 和 GIMP）。事实上，整个 Linux 系统便是一个自由软件的最佳例子：任何人都可以自由地使用、复制、研究、修改和分发 Linux 的所有底层源代码。所以，在 Linux 中使用自由软件是被鼓励的，我们从安装 LibreOffice 开始：\nsudo pacman -S libreoffice-still libreoffice-still-en-gb libreoffice-still-zh-cn\n\n安装 LibreOffice 需要同时安装语言包，我们先安装英国英语和简体中文。安装完成之后点击左上角（类似 Windows 的开始），就可以看到安装好的套件了。\n\n测试\n后记Arch Linux 的安装（即使作为 Linux distro 也）并不简单，这与 Arch 的原则有关：每个人的需求都不同，于是用户被允许从最底层开始搭建自己想要的系统。同时，Arch Linux 也有着 Archer 引以为傲的 Arch Wiki，在那里有着最靠谱的关于 Arch 的问题的解答。事实上，这篇教程只是万千可能性中的一种，你可以设置更复杂的分区，可以不使用 Xfce 桌面环境，可以不用 Vim 而是用 Emacs；当然，我们的 Linux 旅程也远没有结束。\n祝安装 Arch Linux 顺利，祝使用 Arch Linux 愉快！\n","categories":["Linux"],"tags":["Arch"]},{"title":"Waydroid教学：在Arch Linux电脑跑Android APP","url":"/2023/07/13/Waydroid%E6%95%99%E5%AD%A6%EF%BC%9A%E5%9C%A8Arch-Linux%E7%94%B5%E8%84%91%E8%B7%91Android-APP/","content":"转载:https://ivonblog.com/posts/archlinux-waydroid/#0-waydroid%E7%89%B9%E8%89%B2\nWaydroid教学：在Arch Linux电脑跑Android APPWaydroid是Anbox配合Halium技术开发的LXC Android容器，可在GNU&#x2F;Linux系统执行Android APP。\n\n作业系统：Arch Linux\nLinux核心版本：6.3.2\nWaydroid映像档版本：LineageOS 18 (Android 11)\nCPU: Intel I5-7400\nGPU: Intel UHD 630\n\n0. Waydroid特色以下是Waydroid的特色功能：\n\nLinux平台自由开源的Android容器解决方案\n支援x86与ARM架构的装置\n与宿主机共用剪贴簿\n直接使用电脑显示卡硬体加速，跑3D游戏、看影片没什么问题。\n內建GAPPS，可以使用Google Play\n支援给x86装置安装ARM转译器\n支援安装Widevine DRM模组\n支援Magisk\n\n1. 设定显示卡与Linux核心1.1. 切换至WaylandWaydroid必须使用Wayland显示协定，用此指令检查目前的工作阶段是否为Wayland：\necho $XDG_SESSION_TYPE \n\n若显示X11代表不是Wayland。GNOME和KDE可在登入画面切换至Wayland工作阶段。\n如果想在X11工作阶段使用Waydroid，请安装Weston，再参考文末作法。\n1.2. 安装binder核心模组Waydroid要求Linux核心支援binder核心模组，但Arch Linux预设的linux核心並无开启此选项，因此需要从AUR安装binder_linux-dkms补齐。\nyay -S binder_linux-dkms \n\n安装后载入binder核心模组\nsudo modprobe binder_linux\n\n设定开机自动载入核心模组\nsu echo &quot;binder_linux&quot; &gt;&gt; /etc/modules-load.d/binder.conf \n\n2. 安装Waydroid\n从AUR安装Waydroid：\n\nyay -S python-pyclip xclip wl-clipboard mailcap yay -S waydroid\n\n\n初始化Waydroid，下载含有GAPPS的Android系统映像档。\n\nsudo waydroid init -s GAPPS -f    #要魔法,不然很慢或者yay -S waydroid-image-gappswaydroid init -s GAPPS -f\n\n\n启动Waydroid容器服务\n\nsudo systemctl start waydroid-container # 开机自动启动 sudo systemctl enable waydroid-container \n\n\n由於图形驱动程式的缘故，目前Waydroid只支援Intel和AMD的显示卡，Nvidia显示卡会没画面。请看本文最下面的额外作法。\n点选应用程式列表的「Waydroid」图示开启主画面，或者使用指令：waydroid show-full-ui\n若Waydroid没有网路，允许其通过防火墙：\n\nsudo ufw allow 53 sudo ufw allow 67 sudo ufw default allow FORWARD sudo ufw reload sudo systemctl restart waydroid-container\n\n3. 將Waydroid註册为Google装置\nWaydroid第一次开机可能会收到Device is not Play Protect certified的通知，无法登入Google帐號。\n\n\n\n此时要取得casualsnek製作的指令稿，用於取得Waydroid的装置ID。该指令会印出一长串数字。\n\nsudo pacman -S lzip sqlite python3 python-pipcd ~git clone https://github.com/casualsnek/waydroid_scriptcd ~/waydroid_scriptsudo python3 -m pip install -r requirements.txtcd ~/waydroid_scriptsudo python3 main.py certified\n\n\n开启装置註册页面，登入Google帐號，输入装置ID註册，等个半小时应该就能登入Google帐號了。如果还是不行就重新启动Waydroid容器服务：\n\nsudo systemctl restart waydroid-container\n\n\n现在可以安装APP了，Google Play和F-Droid会自动筛出適合x86架构的APP。\n\n4. 安装ARM转译器libhoudini很多APP只为手机的ARM架构打造，但大多数电脑都是x86架构，为此你需要安装ARM转译器才能执行ARM架构的APP。\n目前ARM→x86的转译器有libhoudini和libndk，前者比后者稳定些。casualsnek指令稿的libhoudini是从Microsoft Android Subsytem for Windows所抽取出来。\n\n执行casualsnek的指令稿安装libhoudini：\n\ncd ~/waydroid_script sudo python3 main.py install libhoudini \n\n\n重启Waydroid\n\nsudo systemctl restart waydroid-container\n\n\n试著安装Subway Surfers这款仅提供ARM架构的小游戏。如果开的起来代表ARM转译器正常运作。\n\n5. Waydroid相关指令若Waydroid无法启动，请善用sudo systemctl status waydroid-container和waydroid log和sudo waydroid logcat查看错误讯息。\n用指令开启Waydroid主画面\nwaydroid show-full-ui或者waydroid session start\n\n启动&#x2F;停止Waydroid容器服务\nsudo systemctl start waydroid-container sudo systemctl stop waydroid-container \n\n\nWaydroid在启动后可以进入Android shell，並且有Root权限\nsudo waydroid shell \n\nWaydroid用此指令安装APK\nwaydroid app install &lt;APK档案&gt;.apk \n\n让Waydroid开启多视窗模式，变成好像Linux的原生应用程式一般。启动后按F11切换\nwaydroid prop set persist.waydroid.multi_windows true sudo systemctl restart waydroid-container\n\n如果要完全移除Waydroid：\nwaydroid session stop sudo systemctl stop waydroid-container yay -Rsn waydroid sudo rm -rf /var/lib/waydroid /home/.waydroid ~/waydroid ~/.share/waydroid ~/.local/share/applications/*aydroid* ~/.local/share/waydroid \n\nWaydroid的Android系统资料放在~/.local/share/waydroid/data/，系统映像档位於/var/lib/waydroid，APP图示位於~/.local/share/applications/\n6. 有关Waydroid的疑难杂症6.1. 解决Nivida显示卡的问题由於Nvidia图形驱动程式不遵守公开標准，目前Waydroid在Nvidia显示卡无法启动。\n硬要的话，编辑/var/lib/waydroid/waydroid_base.prop，加入以下內容改用效能极差的软体渲染。\nro.hardware.gralloc=default ro.hardware.egl=swiftshader # 接著执行sudo systemctl restart waydroid-container\n\n\n\n6.2. 如何在X11环境启动Waydroid\n启动Weston\n\nweston\n\n\n在Weston视窗开启终端机，启动Waydroid主画面\n\nexport XDG_SESSION_TYPE=wayland waydroid show-full-ui                                                   \n\n6.3. 不想要Waydroid APP图示出现在桌面Waydroid的Android APP图示位於~/.local/share/applications/*aydroid\n写个指令稿於Waydroid关闭后刪除之。\n6.4. Waydroid APP无法写入內部储存空间如果出现此问题，请使用casualsnek的指令稿修正目录权限：\n复製\ncd ~/waydroid_script sudo python3 main.py hack nodataperm sudo systemctl restart waydroid-container \n\n参考资料\nWaydroid - ArchWiki\nInstall Instructions - Waydroid\nWaydroid container failed to start #189\n折腾记录:Waydroid透过Weston在X11下运行\n\n","categories":["Linux"],"tags":["Arch","Waydroid"]},{"title":"arch创建ap热点","url":"/2023/07/04/arch%E5%88%9B%E5%BB%BAap%E7%83%AD%E7%82%B9/","content":"首先安装create_apsudo pacman -S create_ap\n\n使用ip adrr查询网卡ip addr\n\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo     valid_lft forever preferred_lft forever    inet6 ::1/128 scope host      valid_lft forever preferred_lft forever 3: wlo1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000    link/ether 1a:5b:3d:79:ae:a9 brd ff:ff:ff:ff:ff:ff permaddr ac:67:5d:56:3d:1c    altname wlp0s20f3 4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:80:ed:05:ab brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0     valid_lft forever preferred_lft forever    inet6 fe80::42:80ff:feed:5ab/64 scope link proto kernel_ll      valid_lft forever preferred_lft forever 6: veth1c27a56@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default     link/ether ce:94:2a:2d:bd:83 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet6 fe80::cc94:2aff:fe2d:bd83/64 scope link proto kernel_ll      valid_lft forever preferred_lft forever 7: utun: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 9000 qdisc mq state UNKNOWN group default qlen 500    link/none     inet 198.18.0.1/16 scope global utun     valid_lft forever preferred_lft forever    inet6 fe80::86d:2369:2a6e:9c5b/64 scope link stable-privacy proto kernel_ll      valid_lft forever preferred_lft forever 10: enp0s20f0u6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000    link/ether 00:e0:4c:36:85:7b brd ff:ff:ff:ff:ff:ff    inet 192.168.1.51/24 brd 192.168.1.255 scope global dynamic noprefixroute enp0s20f0u6     valid_lft 13079sec preferred_lft 13079sec    inet6 fe80::4ea7:6c93:4d72:8bd3/64 scope link noprefixroute      valid_lft forever preferred_lft forever 11: ap0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000    link/ether ac:67:5d:56:3d:1d brd ff:ff:ff:ff:ff:ff    inet 192.168.12.1/24 brd 192.168.12.255 scope global ap0     valid_lft forever preferred_lft forever    inet6 fe80::ae67:5dff:fe56:3d1d/64 scope link proto kernel_ll      valid_lft forever preferred_lft forever\n\nwlo1为无线网卡，enp0s20f0u6为有线网卡\n创建热点有线网卡创建\nsudo create_ap wlo1 enp0s20f0u1 wifiname wifipwd\n\n无线网卡创建\nsudo create_ap wlo1 wlo1 wifiname wifipwd\n\nwifiname:热点名称\nwifipwd:热点密码（如果不需要密码可以不加）\nps：\n写了个脚本开热点，但是有点bug\n#!/bin/bashwifiname=$1wifipwd=$2para=$(cat /proc/net/dev | awk &#x27;&#123;i++; if(i&gt;2)&#123;print $1&#125;&#125;&#x27; | sed &#x27;s/^[\\t]*//g&#x27; | sed &#x27;s/[:]*$//g&#x27;)wifi=$(echo $*&quot;$para&quot;)wol=&quot;&quot;enp=&quot;&quot;for i in $wifidoif [[ $i =~ ^[w]\\w* ]];then    wol=$ielif [[ $i =~ ^[e]\\w* ]];then    enp=$ifidoneif [[ $# -gt 0 &amp;&amp; $# -le 2 ]]then    create_ap $wol $enp $wifiname $wifipwdfi\n\n","categories":["Linux"],"tags":["Arch"]},{"title":"arch用dhcpcd设置静态ip后无法上网","url":"/2023/06/07/arch%E7%94%A8dhcpcd%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip%E5%90%8E%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/","content":"arch用dhcpcd配置静态ip后无法上网，ping baidu.com提示消息Temporary failure in name resolution\n原因是由于&#x2F;etc&#x2F;resolv.conf中的dns配置被覆盖\n可创建&#x2F;etc&#x2F;resolv.conf.head和&#x2F;etc&#x2F;resolv.conf.tail写入nameserver xxx.xxx.xxx.xx解决覆盖问题\n","categories":["Linux"],"tags":["Arch"]},{"title":"kde使用Wallpaper Engine","url":"/2023/07/05/kde%E4%BD%BF%E7%94%A8Wallpaper-Engine/","content":"安装Wallpaper Engine KDE Pluginkde现在已经可以直接在桌面设置拉取Wallpaper Engine KDE Plugin\n\n获取可以去github获取Wallpaper Engine KDE Plugin的源码自行编译项目地址：https://github.com/catsout/wallpaper-engine-kde-plugin\n安装Wallpaper Engine本系统为archlinux\n添加archlinuxcn源\nsudo nano /etc/pacman.conf\n\n在底部添加以下行。\n[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n\n保存后执行sudo pacman -Sy archlinuxcn-keyring更新软件数据库并安装 ArchLinuxCN GPG 密钥\n安装yay\nsudo pacman -S yay\n\n使用yay安装steam\nyay -S steam\n\n在steam设置中启用steam play\n\n然后才能安装壁纸引擎\n使用Wallpaper Engine KDE Plugin使用Wallpaper Engine下载好壁纸后，选择壁纸目录&#x2F;&#x2F;home&#x2F;user&#x2F;.local&#x2F;share&#x2F;Steam\n可以右键文件夹选择显示隐藏目录\n问题：1、scene类型的壁纸无法应用，原因是因为scene壁纸还需要安装vulkan\nsudo pacman -S mesa xf86-video-intel vulkan-intel\n\n我这边执行这一条语句就解决了\n更详细的驱动安装参考这篇文章：https://blog.csdn.net/qq_25675517/article/details/120733383\n2、scene壁纸无法填满屏幕\n将单个壁纸Display设置为Scale to Full，或者在settings将默认Display设置为Scale to Full\n","categories":["Linux"],"tags":["Arch"]},{"title":"mybatis代码生成器","url":"/2023/09/13/mybatis%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/","content":"mybatisgeneratorConfig.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;properties resource=&quot;generator.properties&quot;/&gt;    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!-- 为模型生成序列化方法--&gt;        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;        &lt;!--生成mapper.xml时覆盖原文件--&gt;        &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;        &lt;commentGenerator type=&quot;com.macro.CommentGenerator&quot;&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;            &lt;!-- 是否不生成时间，默认false，也就是注释 --&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;            &lt;!-- 是否在实体类的字段上生成对应表列的注释，若suppressAllComments=true，则该属性被忽略 --&gt;            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driverClass&#125;&quot;                        connectionURL=&quot;$&#123;jdbc.connectionURL&#125;&quot;                        userId=&quot;$&#123;jdbc.userId&#125;&quot;                        password=&quot;$&#123;jdbc.password&#125;&quot;&gt;            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;            &lt;!--nullCatalogMeansCurrent = true: 返回指定库涉及表                nullCatalogMeansCurrent = false: 返回所有库涉及表--&gt;            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;        &lt;/jdbcConnection&gt;        &lt;javaModelGenerator targetPackage=&quot;com.macro.model&quot; targetProject=&quot;mall-mbg\\src\\main\\java&quot;/&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.macro.mapper&quot; targetProject=&quot;mall-mbg\\src\\main\\resources&quot;/&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.macro.mapper&quot;                             targetProject=&quot;mall-mbg\\src\\main\\java&quot;/&gt;        &lt;!--生成全部表tableName设为%--&gt;        &lt;table tableName=&quot;%&quot;&gt;            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n\ngenerator.properties\njdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.connectionURL=jdbc:mysql://localhost:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghaijdbc.userId=rootjdbc.password=123456\n\nCommentGenerator\npackage com.macro;import org.mybatis.generator.api.IntrospectedColumn;import org.mybatis.generator.api.IntrospectedTable;import org.mybatis.generator.api.dom.java.CompilationUnit;import org.mybatis.generator.api.dom.java.Field;import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType;import org.mybatis.generator.internal.DefaultCommentGenerator;import org.mybatis.generator.internal.util.StringUtility;import java.util.Properties;/** * 自定义注释生成器 */public class CommentGenerator extends DefaultCommentGenerator &#123;    private boolean addRemarkComments = false;    private static final String EXAMPLE_SUFFIX=&quot;Example&quot;;    private static final String MAPPER_SUFFIX=&quot;Mapper&quot;;    private static final String API_MODEL_PROPERTY_FULL_CLASS_NAME=&quot;io.swagger.annotations.ApiModelProperty&quot;;    /**     * 设置用户配置的参数     */    @Override    public void addConfigurationProperties(Properties properties) &#123;        super.addConfigurationProperties(properties);        this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;));    &#125;    /**     * 给字段添加注释     */    @Override    public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) &#123;        String remarks = introspectedColumn.getRemarks();        //根据参数和备注信息判断是否添加备注信息        if(addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks))&#123;//            addFieldJavaDoc(field, remarks);            //数据库中特殊字符需要转义            if(remarks.contains(&quot;\\&quot;&quot;))&#123;                remarks = remarks.replace(&quot;\\&quot;&quot;,&quot;&#x27;&quot;);            &#125;            //给model的字段添加swagger注解            field.addJavaDocLine(&quot;@ApiModelProperty(value = \\&quot;&quot;+remarks+&quot;\\&quot;)&quot;);        &#125;    &#125;//    /**//     * 给model的字段添加注释//     *///    private void addFieldJavaDoc(Field field, String remarks) &#123;//        //文档注释开始//        field.addJavaDocLine(&quot;/**&quot;);//        //获取数据库字段的备注信息//        String[] remarkLines = remarks.split(System.getProperty(&quot;line.separator&quot;));//        for(String remarkLine:remarkLines)&#123;//            field.addJavaDocLine(&quot; * &quot;+remarkLine);//        &#125;//        addJavadocTag(field, false);//        field.addJavaDocLine(&quot; */&quot;);//    &#125;    @Override    public void addJavaFileComment(CompilationUnit compilationUnit) &#123;        super.addJavaFileComment(compilationUnit);        //只在model中添加swagger注解类的导入        if(!compilationUnit.getType().getFullyQualifiedName().contains(MAPPER_SUFFIX)&amp;&amp;!compilationUnit.getType().getFullyQualifiedName().contains(EXAMPLE_SUFFIX))&#123;            compilationUnit.addImportedType(new FullyQualifiedJavaType(API_MODEL_PROPERTY_FULL_CLASS_NAME));        &#125;    &#125;&#125;\n\nmain\npackage com.macro;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.InputStream;import java.util.ArrayList;import java.util.List;public class Generator &#123;    public static void main(String[] args) throws Exception &#123;        //MBG 执行过程中的警告信息        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        //当生成的代码重复时，覆盖原代码        boolean overwrite = true;        //读取我们的 MBG 配置文件        InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(is);        is.close();        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        //创建 MBG        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);        //执行生成代码        myBatisGenerator.generate(null);        //输出警告信息        for (String warning : warnings) &#123;            System.out.println(warning);        &#125;    &#125;&#125;\n\nmybatis-plus步骤1:创建一个Maven项目代码2:导入对应的jar包&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.1&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;mybatisplus_04_generator&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--spring webmvc--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--mybatisplus--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--druid--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.16&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--test--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--lombok--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--代码生成器--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;            &lt;version&gt;3.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--velocity模板引擎--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;            &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;            &lt;version&gt;2.3&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n步骤3:编写引导类@SpringBootApplicationpublic class Mybatisplus04GeneratorApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Mybatisplus04GeneratorApplication.class, args);    &#125;&#125;\n\n步骤4:创建代码生成类public class CodeGenerator &#123;    public static void main(String[] args) &#123;        //1.获取代码生成器的对象        AutoGenerator autoGenerator = new AutoGenerator();        //设置数据库相关配置        DataSourceConfig dataSource = new DataSourceConfig();        dataSource.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC&quot;);        dataSource.setUsername(&quot;root&quot;);        dataSource.setPassword(&quot;root&quot;);        autoGenerator.setDataSource(dataSource);        //设置全局配置        GlobalConfig globalConfig = new GlobalConfig();        globalConfig.setOutputDir(System.getProperty(&quot;user.dir&quot;)+&quot;/mybatisplus_04_generator/src/main/java&quot;);    //设置代码生成位置        globalConfig.setOpen(false);    //设置生成完毕后是否打开生成代码所在的目录        globalConfig.setAuthor(&quot;黑马程序员&quot;);    //设置作者        globalConfig.setFileOverride(true);     //设置是否覆盖原始生成的文件        globalConfig.setMapperName(&quot;%sDao&quot;);    //设置数据层接口名，%s为占位符，指代模块名称        globalConfig.setIdType(IdType.ASSIGN_ID);   //设置Id生成策略        autoGenerator.setGlobalConfig(globalConfig);        //设置包名相关配置        PackageConfig packageInfo = new PackageConfig();        packageInfo.setParent(&quot;com.aaa&quot;);   //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径        packageInfo.setEntity(&quot;domain&quot;);    //设置实体类包名        packageInfo.setMapper(&quot;dao&quot;);   //设置数据层包名        autoGenerator.setPackageInfo(packageInfo);        //策略设置        StrategyConfig strategyConfig = new StrategyConfig();        strategyConfig.setInclude(&quot;tbl_user&quot;);  //设置当前参与生成的表名，参数为可变参数        strategyConfig.setTablePrefix(&quot;tbl_&quot;);  //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_        strategyConfig.setRestControllerStyle(true);    //设置是否启用Rest风格        strategyConfig.setVersionFieldName(&quot;version&quot;);  //设置乐观锁字段名        strategyConfig.setLogicDeleteFieldName(&quot;deleted&quot;);  //设置逻辑删除字段名        strategyConfig.setEntityLombokModel(true);  //设置是否启用lombok        autoGenerator.setStrategy(strategyConfig);        //2.执行生成操作        autoGenerator.execute();    &#125;&#125;\n\n对于代码生成器中的代码内容，我们可以直接从官方文档中获取代码进行修改，\nhttps://mp.baomidou.com/guide/generator.html\n","categories":["数据库"],"tags":["mybatis"]},{"title":"openWRT Ubuntu环境搭建及交叉编译工具制作与使用","url":"/2023/05/21/openWRT-Ubuntu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"Openwrt本身不支持直接编译C语言的，不支持GCC，因此，我们在Ubuntu下写好的代码，通过gcc编译后的可执行文件是不能直接在openWRT上运行的。\n 因此，我们需要制作基于openWRT的交叉编译工具 toolchain。\n \n\n\n搭建开发环境1.1 openWRT下载 下载Chaos Calmer (15.05)正式发行版\n git clone -b chaos_calmer https://github.com/openwrt/openwrt\n1.2 openWRT依赖安装 在编译openWRT之前，需要安装依赖，否则会自动停止进入make menuconfig。\n 一次性安装所需依赖组件，输入：\n sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev subversion git-core gawk asciidoc libz-dev zlib1g-dev libssl-dev openssl\n 分步安装如下：\n sudo apt-get install g++\n sudo apt-get install libncurses5-dev\n sudo apt-get install zlib1g-dev\n sudo apt-get install bison\n sudo apt-get install flex\n sudo apt-get install unzip\n sudo apt-get install autoconf\n sudo apt-get install gawk\n sudo apt-get install make\n sudo apt-get install gettext\n sudo apt-get install gcc\n sudo apt-get install binutils\n sudo apt-get install patch\n sudo apt-get install bzip2\n sudo apt-get install libz-dev\n sudo apt-get install asciidoc\n sudo apt-get install subversion\n sudo apt-get install sphinxsearch\n sudo apt-get install libtool\n sudo apt-get install sphinx-common\n sudo apt-get install openssl (新加的依赖库)\n 安装完成后需要重启终端\n Feeds是OpenWRT环境所需要的软件包套件.比较重要的feeds有：\n pacakges’：一些额外的基础路由器特性软件\n ‘LuCI’：OpenWRT默认的GUI\n ‘Xwrt’：另一种可选的GUI界面\n .&#x2F;scripts&#x2F;feeds update -a\n .&#x2F;scripts&#x2F;feeds install -a\n1.3 openWRT toolchain编译 1.3.1 配置 menuconfig\n cd openwrt\n make menuconfig\n 进入下图所示的menuconfig配置界面，进行如下配置：\n  1、Target System\n  我手上的路由器CPU芯片是MT7620A，所以配置为 RT288x\n  2、Subtarget\n  配置为MT7620\n  3、Target Profile\n  配置为MT7620a EVB\n  4、Package the OpenWrt-based Toolchain\n  因为我们要制作toolchain交叉编译工具，所以这里通过click 空格键来切换到 “*”为选中状态\n\n1.3.2 编译 Toolchain 配置完成后，保存并退出，然后输入命令编译：\n[注意]本次编译过程中需要从国外站点下载所需的依赖文件，因此，编译之前必须挂载VPN来允许访问境外网站，且保证网络稳定，整个编译过程大概为2-4个小时。make V=s\n\n 一切无错的情况下,会在 openwrt源码目录&#x2F;bin&#x2F;ramips&#x2F; 目录下找到编译好的toolchain OpenWrt-Toolchain-ramips-mt7620_gcc-4.8-linaro_uClibc-0.9.33.2.Linux-x86_64.tar.bz2\n 编译交叉编译工具链，有X86和X64之分，根据系统有关系，因此使用现有的toolchain的时候，注意区分系统。\n 编译成功后如下图所示：\n\n1.3.3 安装 Toolchain  openWRT的交叉编译工具链需要安装到当前系统中，我使用的是Ubuntu 64，然后配置环境变量，才能使用。步骤如下：\n1、解压toolchain  将交叉编译工具链解压到Ubuntu的“、opt”目录下，载openWRT的更目录下运行：\nsudo tar jxvf ./bin/ramips/OpenWrt-Toolchain-ramips-mt7620_gcc-4.8-linaro_uClibc-0.9.33.2.Linux-x86_64.tar.bz2 -C /opt/\n\n2、设置环境变量  执行 sudo gedit &#x2F;etc&#x2F;bash.bashrc打开文件，在文件最后添加如下配置：\nexport PATH=/opt/OpenWrt-Toolchain-ramips-mt7620_gcc-4.8-linaro_uClibc-0.9.33.2.Linux-x86_64/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-0.9.33.2/bin:$PATHexport STAGING_DIR=/~/workspace/openwrt/staging_dir\n\n  其中， export STAGING_DIR配置的是STAGING路径，取决于你openWRT源码的路径。\n  保存后，执行如下命令：\nsource /etc/bash.bashrc\n\n3、检查是否安装成功执行命令：mipsel-openwrt-linux-gcc -v\n\n 安装toolchain，如下图所示：\n\n 上图中，Error：ld不用管。\n1.3.4 Toolchain测试1、编写hello.c 测试程序：hello.c\n 源码：\n #include &lt;stdio.h&gt;\n int main(void)\n {\n  unsigned char i &#x3D; 0;\n  while(1)\n  {\n  printf(“\\n hello openWRT! %d\\n”, i);\n  sleep(1);\n  }\n  return 0;\n }\n2、交叉编译 mipsel-openwrt-linux-gcc hello.c -o hello\n 生成可执行文件  hello\n  该可执行文件是试用openWRT的toolchain编译所得，是无法在Ubuntu上直接运行的，需要拷贝到openWRT里运行。\n3、通过winSCP放到openWRT 用户名：root\n 密码：root\n\n4、通过SSH远程登陆后执行\n\n\n 添加X可执行权限：\n chmod 777 hello\n 执行.&#x2F;hello\n\n","categories":["路由器"],"tags":["openwrt，ubuntu"]},{"title":"openwrt-Feeds源修改","url":"/2023/05/21/openwrt-Feeds%E6%BA%90%E4%BF%AE%E6%94%B9/","content":"修改 OpenWRT顶层目录下的 feeds.conf.default 文件，更换源地址：\n 原文件代码：\nsrc-git packages https://git.openwrt.org/feed/packages.gitsrc-git luci https://git.openwrt.org/project/luci.gitsrc-git routing https://git.openwrt.org/feed/routing.gitsrc-git telephony https://git.openwrt.org/feed/telephony.gitsrc-git freifunk https://github.com/freifunk/openwrt-packages.git#src-git video https://github.com/openwrt/video.git#src-git targets https://github.com/openwrt/targets.git#src-git management https://github.com/openwrt-management/packages.git#src-git oldpackages http://git.openwrt.org/packages.git#src-link custom /usr/src/openwrt/custom-feed\n\n修改：\nsrc-git packages https://github.com/widora/packages.git;widora_dlna_patchessrc-git luci https://github.com/widora/luci.git;mastersrc-git routing https://github.com/openwrt-routing/packages.git;for-15.05src-git telephony https://github.com/openwrt/telephony.git;for-15.05src-git management https://github.com/openwrt-management/packages.git;for-15.05#src-git targets https://github.com/openwrt/targets.git#src-git oldpackages http://git.openwrt.org/packages.git#src-svn xwrt http://x-wrt.googlecode.com/svn/trunk/package#src-svn phone svn://svn.openwrt.org/openwrt/feeds/phone#src-svn efl svn://svn.openwrt.org/openwrt/feeds/efl#src-svn xorg svn://svn.openwrt.org/openwrt/feeds/xorg#src-svn desktop svn://svn.openwrt.org/openwrt/feeds/desktop#src-svn xfce svn://svn.openwrt.org/openwrt/feeds/xfce#src-svn lxde svn://svn.openwrt.org/openwrt/feeds/lxde#src-link custom /usr/src/openwrt/custom-feed\n\n","categories":["路由器"],"tags":["openwrt"]},{"title":"openwrt编译教程","url":"/2023/05/21/openwrt%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/","content":"编译openwrt建议在非大陆的云服务器上进行（竞价实例真香，比去网吧打游戏还便宜），可以有效提高下载依赖等文件的成功率，如果持续需要编译，可以编译一次全插件全驱动的，然后吧dl文件夹打个包下载到本地完成之后的编译，避免持续缴费\n建议使用Ubuntu系统，教程多，出了问题搜起来也简单一些，可以用WSL但是不建议在ntfs以及refs文件系统中编译，不建议使用powershell进行编译\n然后安利一下Microsoft Terminal https://github.com/microsoft/terminal\n也可以在Windows应用商店下载\n\n\nOne Half Dark这个默认配色深得我心\n\n正文：不要使用root用户，Ubuntu默认用户是ubuntu可以直接使用，其他系统或登录就是root的情况，考虑新建一个用户再来进行编译\n以下内容可以直接复制到终端中运行，#开头的行会被终端忽略，一起复制也没有问题\n#编译前的准备####更新软件（可选）####sudo sh -c &quot;apt update &amp;&amp; apt upgrade -y&quot;#########################安装依赖sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync libelf-dev python3-distutils#克隆源码git clone https://github.com/coolsnowwolf/lede.git#进入源码文件夹cd lede######添加自定义源（可选）##########cat &gt;&gt; feeds.conf.default &lt;&lt;EOFsrc-git kenzo https://github.com/kenzok8/openwrt-packagessrc-git passwall https://github.com/xiaorouji/openwrt-passwallsrc-git nas https://github.com/linkease/nas-packages.gitEOF#####################################更新并安装feeds.conf.default中配置的源./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -a######添加 OpenAppFilter 应用过滤插件（可选）####git clone https://github.com/destan19/OpenAppFilter package/OpenAppFilter#######################################################更改默认主题（可选）############ 删除自定义源默认的 argon 主题rm -rf package/lean/luci-theme-argon# 拉取 argon 原作者的源码git clone -b 18.06 https://github.com/jerrykuku/luci-theme-argon.git package/lean/luci-theme-argon# 替换默认主题为 luci-theme-argonsed -i &#x27;s/luci-theme-bootstrap/luci-theme-argon/&#x27; feeds/luci/collections/luci/Makefile#make menuconfig时记得勾选LuCI ---&gt; Applications ---&gt; luci-app-argon-config#########################################设置路由器默认的管理地址为.5.1（可选）###sed -i &#x27;s/192.168.1.1/192.168.5.1/g&#x27; package/base-files/files/bin/config_generate##############################################根据需要选插件make menuconfig#记得在Target Images适当扩大系统分区和镜像大小#系统分区，驱动或插件多的话需要适当扩大这个分区#(128) Kernel partition size (in MB)#文件系统分区，基本可以理解为安装后默认的/overlay分区大小#(512) Root filesystem partition size (in MB)#下载编译所需的软件包make download -j8 V=s#看看有没有没下完整的包，这是查看dl目录下有没有1k以下的文件，有的话建议删除重新下，很可能没下完整find dl -size -1024c -exec ls -l &#123;&#125; \\;#删除find dl -size -1024c -exec rm -f &#123;&#125; \\;\n\n现在区分首次编译和二次编译\n首次编译# -j1：单线程编译make -j1 V=s#这时候如果报错bash: po2lmo: command not found，八成是base没有先编译出来#可以运行以下命令先编译base，然后重新执行make -j1 V=smake package/feeds/luci/luci-base/compile V=s#剩下的可能就是插件冲突之类的，没有很好的办法，慢慢排查吧\n\n二次编译#首先肯定是要进入lede目录: cd lede#拉取最新代码git pull#更新下载安装订阅源包含的软件包./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -af#清理旧文件#如果只是调整检查和驱动等make clean#如果需要调整架构，或者之前编译出错make dirclean#删除旧的配置文件rm -rf ./tmp &amp;&amp; rm -rf .config#选择插件make menuconfig#下载包make download -j8 V=s#优先使用多线程编译，出错则使用单线程并输出详细信息make -j$(nproc) ||  make -j1 V=s\n\n一些工具：\n\n因为编译对网络环境有点要求，通常使用海外的服务器进行编译，就存在一个传输问题，特别是dl之类的目录需要下载回国内时，传输还是很费劲的，推荐一个Linux上直接可以上传Google云盘的工具：GitHub - veip007&#x2F;Linux-to-Google-Drive: Linux下谷歌网盘同步工具、自动备份VPS文件到Google Drive\n如果是按流量计费那么压缩完上传可能会省个几块钱(7z真好用)：\n\n7za a -m0=lzma -mx=9 -ms=on lede.7z lede/ &amp;\n\n\n有些朋友私信来问我怎么配hyper-v：得到发生：Hyper-V虚拟机安装OpenWRT软路由系统 （双网口主路由）\n\n这个朋友已经写得很详细了，可以参考一下他的，别忘了看完给人家点个赞\n坑：\n\n不清楚是不是我的网络问题还是和哪个插件冲突AdGuard Home一旦勾选，有概率编译失败，编译成功该插件也无法正常使用\n\n参考：\nOpenWrt 固件自编译教程：从入门到酸爽！ - 喵斯基部落\nhttps://github.com/fw876/hellow\n","categories":["路由器"],"tags":["openwrt"]},{"title":"springboot实现token","url":"/2023/07/17/springboot%E5%AE%9E%E7%8E%B0token/","content":"1.导入依赖&lt;dependency&gt;    &lt;groupId&gt;com.auth0&lt;/groupId&gt;    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;    &lt;version&gt;3.18.1&lt;/version&gt;&lt;/dependency&gt;\n\napplication.yml配置\nenroll:  token:    secret: &#x27;5xcJVrXNyQDIxK1l2RS9nw&#x27;\n\n2.拦截器配置CertificationInterceptor\nSlf4j@Componentpublic class CertificationInterceptor implements HandlerInterceptor &#123;    @Autowired    private UserDao userDao;    @Autowired    private TokenDao tokenDao;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        if (!HttpMethod.OPTIONS.matches(request.getMethod())) &#123;            String tokenString = request.getHeader(&quot;token&quot;);            if (StrUtil.isEmpty(tokenString)) &#123;                return false;            &#125;            int userId = -1;            try &#123;                userId = TokenUtils.verify(tokenString);            &#125; catch (TokenExpiredException e) &#123;                return false;            &#125; catch (Exception e) &#123;                return false;            &#125;            Token token = tokenDao.selectByTokenString(tokenString);//数据库查询token            if (token == null || token.getUserId() != userId || token.getExpired().getTime() &lt; System.currentTimeMillis()) &#123;                // 无效的token                return false;            &#125;        &#125;        return false;    &#125;\n\nWebConfig\n@Slf4j@Componentpublic class WebConfig implements WebMvcConfigurer &#123;    @Autowired    private CertificationInterceptor certificationInterceptor;    /**     * 拦截器配置     *     * @param registry     */    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(certificationInterceptor)                .addPathPatterns(&quot;/user/**&quot;, &quot;/resource/**&quot;)                .excludePathPatterns(&quot;/file/**&quot;,                        &quot;/user/auth&quot;,                        &quot;/user/checkEnrollToken&quot;,                        &quot;/user/admin/auth&quot;,                        &quot;/user/getAccessToken&quot;,                        &quot;/user/getToken&quot;,                        &quot;/user/getTokenTest&quot;,                        &quot;/user/checkPhone&quot;,                        &quot;/user/checkSid&quot;,                        &quot;/user/search&quot;,                        &quot;/resource/dynamic/**&quot;,                )                .order(0)        ;    &#125;\n\nTokenUtils\n@Slf4j@Componentpublic class TokenUtils  &#123;    /**     * 默认过期时间(7天)     */    private static final long EXPIRE_TIME = 7 * 24 * 60 * 60 * 1000L;    /**     * 加密私钥     */    private static String tokenSecret;    public TokenUtils(@Value(value = &quot;$&#123;enroll.token.secret&#125;&quot;) String tokenSecret) &#123;        TokenUtils.tokenSecret = tokenSecret;    &#125;\t\t/**     * 创建token(默认过期时间为24小时)     *     * @param userId 用户id     * @return     */    public static Token createToken(int userId) &#123;        Date expired = new Date(System.currentTimeMillis() + EXPIRE_TIME);        return createTokenAndSpecifyExpirationTime(userId, expired);    &#125;\t\t/**     * 创建token并指定过期时间     *     * @param userId         用户id     * @param expirationTime 过期时间     * @return     */    public static Token createTokenAndSpecifyExpirationTime(int userId, Date expirationTime) &#123;        Date createTime = new Date();\t\t//根据用户id，加密生成真正的token字符串        String tokenString = generateTokenString(userId, expirationTime);        Token token = new Token();        token.setUserId(userId);        token.setExpired(expirationTime);        token.setToken(tokenString);        token.setStatus(TokenStatusEnum.EFFICIENT.getStatus());        token.setCreateTime(createTime);        token.setUpdateTime(createTime);        return token;    &#125;    /**     * 验证token是否有效     *     * @param tokenString     */    public static int verify(String tokenString) &#123;        Algorithm algorithm = Algorithm.HMAC256(tokenSecret);\t\t//根据algorithm创建JWT校验器        JWTVerifier verifier = JWT.require(algorithm).build();\t\t//对token进行解码        DecodedJWT decodedJWT = verifier.verify(tokenString);\t\t//获取负载payload        //String payload = decodedJWT.getPayload();        //String decodeStr = Base64.decodeStr(payload);        //Map&lt;String, Object&gt; objectMap = JsonUtils.quietlyDeserializeForMap(decodeStr);\t    Claim userId = decodedjwt.getClaim(&quot;userId&quot;);        //Integer userId = (Integer) objectMap.get(&quot;userId&quot;);        Integer userId = (Integer) userId.asString();        return userId != null ? userId : -1;    &#125;    /**     * 根据用户id，加密生成真正的token字符串     *     * @return     */    private static String generateTokenString(int userId, Date expired) &#123;        //加密tokenSecret        Algorithm algorithm = Algorithm.HMAC256(tokenSecret);        Map&lt;String, Object&gt; header = new HashMap&lt;&gt;(2);        header.put(&quot;typ&quot;, &quot;JWT&quot;);        header.put(&quot;alg&quot;, &quot;HS256&quot;);        return JWT.create()                .withHeader(header)                .withIssuer(&quot;xue&quot;) //token的签发人                .withClaim(&quot;userId&quot;, userId)                // 防止并发时，生成相同的token                .withClaim(&quot;safe-code&quot;, UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;))                .withExpiresAt(expired) //添加过期时间                .sign(algorithm); //添加私钥    &#125;         /**     * 判断token是否过期     *     * @return     */    public static boolean isExpiresAt(String tokenString)&#123;        Algorithm algorithm = Algorithm.HMAC256(tokenSecret);        JWTVerifier verifier = JWT.require(algorithm).build();        DecodedJWT decodedJWT = verifier.verify(tokenString);        Date expiresAt = decodedJWT.getExpiresAt();        Date day=new Date();\t\t//day小于expiresAt时返回True        return day.before(expiresAt);    &#125;&#125;\n\n第二种\nAppJwtUtil\nimport io.jsonwebtoken.*;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.*;public class AppJwtUtil &#123;    // TOKEN的有效期一天（S）    private static final int TOKEN_TIME_OUT = 3_600;    // 加密KEY    private static final String TOKEN_ENCRY_KEY = &quot;MDk4ZjZiY2Q0NjIxZDM3M2NhZGU0ZTgzMjYyN2I0ZjY&quot;;    // 最小刷新间隔(S)    private static final int REFRESH_TIME = 300;    // 生产ID    public static String getToken(Long id)&#123;        Map&lt;String, Object&gt; claimMaps = new HashMap&lt;&gt;();        claimMaps.put(&quot;id&quot;,id);        long currentTime = System.currentTimeMillis();        return Jwts.builder()                .setId(UUID.randomUUID().toString())                .setIssuedAt(new Date(currentTime))  //签发时间                .setSubject(&quot;system&quot;)  //说明                .setIssuer(&quot;heima&quot;) //签发者信息                .setAudience(&quot;app&quot;)  //接收用户                .compressWith(CompressionCodecs.GZIP)  //数据压缩方式                .signWith(SignatureAlgorithm.HS512, generalKey()) //加密方式                .setExpiration(new Date(currentTime + TOKEN_TIME_OUT * 1000))  //过期时间戳                .addClaims(claimMaps) //cla信息                .compact();    &#125;    /**     * 获取token中的claims信息     *     * @param token     * @return     */    private static Jws&lt;Claims&gt; getJws(String token) &#123;            return Jwts.parser()                    .setSigningKey(generalKey())                    .parseClaimsJws(token);    &#125;    /**     * 获取payload body信息     *     * @param token     * @return     */    public static Claims getClaimsBody(String token) &#123;        try &#123;            return getJws(token).getBody();        &#125;catch (ExpiredJwtException e)&#123;            return null;        &#125;    &#125;    /**     * 获取hearder body信息     *     * @param token     * @return     */    public static JwsHeader getHeaderBody(String token) &#123;        return getJws(token).getHeader();    &#125;    /**     * 是否过期     *     * @param claims     * @return -1：有效，0：有效，1：过期，2：过期     */    public static int verifyToken(Claims claims) &#123;        if(claims==null)&#123;            return 1;        &#125;        try &#123;            claims.getExpiration()                    .before(new Date());            // 需要自动刷新TOKEN            if((claims.getExpiration().getTime()-System.currentTimeMillis())&gt;REFRESH_TIME*1000)&#123;                return -1;            &#125;else &#123;                return 0;            &#125;        &#125; catch (ExpiredJwtException ex) &#123;            return 1;        &#125;catch (Exception e)&#123;            return 2;        &#125;    &#125;    /**     * 由字符串生成加密key     *     * @return     */    public static SecretKey generalKey() &#123;        byte[] encodedKey = Base64.getEncoder().encode(TOKEN_ENCRY_KEY.getBytes());        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);        return key;    &#125;    public static void main(String[] args) &#123;       /* Map map = new HashMap();        map.put(&quot;id&quot;,&quot;11&quot;);*/        System.out.println(AppJwtUtil.getToken(1102L));        Jws&lt;Claims&gt; jws = AppJwtUtil.getJws(&quot;eyJhbGciOiJIUzUxMiIsInppcCI6IkdaSVAifQ.H4sIAAAAAAAAADWLQQqEMAwA_5KzhURNt_qb1KZYQSi0wi6Lf9942NsMw3zh6AVW2DYmDGl2WabkZgreCaM6VXzhFBfJMcMARTqsxIG9Z888QLui3e3Tup5Pb81013KKmVzJTGo11nf9n8v4nMUaEY73DzTabjmDAAAA.4SuqQ42IGqCgBai6qd4RaVpVxTlZIWC826QA9kLvt9d-yVUw82gU47HDaSfOzgAcloZedYNNpUcd18Ne8vvjQA&quot;);        Claims claims = jws.getBody();        System.out.println(claims.get(&quot;id&quot;));    &#125;&#125;\n\n","categories":["SpringBoot"],"tags":["Java"]},{"title":"springboot解决跨域的方法","url":"/2023/07/17/springboot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/","content":"一、为什么会出现跨域问题出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略\n同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）\n\n二、什么是跨域当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域\n三、java 后端 实现 CORS 跨域请求的方式1.重写 WebMvcConfigurer(全局跨域)@Slf4j@Componentpublic class WebConfig implements WebMvcConfigurer &#123;    /**     * 跨域配置     *     * @param registry     */    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedHeaders(&quot;*&quot;)                .allowedMethods(&quot;*&quot;)                .allowedOrigins(&quot;*&quot;)                .allowCredentials(false) //是否发送Cookie                .maxAge(3600L); //准备响应前的 缓存持续的最大时间    &#125;&#125;\n\n2.使用注解 (局部跨域)在控制器上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。\n@RestController@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)public class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello() &#123;        return &quot;hello world&quot;;    &#125;&#125;\n\n3.手动设置响应头(局部跨域)使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域\n@RequestMapping(&quot;/index&quot;)public String index(HttpServletResponse response) &#123;    response.addHeader(&quot;Access-Allow-Control-Origin&quot;,&quot;*&quot;);    return &quot;index&quot;;&#125;\n\n","categories":["SpringBoot"],"tags":["Java"]},{"title":"ubuntu换镜像源（ubuntu换源）","url":"/2023/05/21/ubuntu%E6%8D%A2%E9%95%9C%E5%83%8F%E6%BA%90%EF%BC%88ubuntu%E6%8D%A2%E6%BA%90%EF%BC%89/","content":"#备份镜像源设置文件\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n\n#编辑镜像源设置文件\nsudo gedit /etc/apt/sources.list\n\n#复制下面的所有内容替换掉原文件中的所有内容(一次只可以选一个镜像源，根据你的情况选)\n阿里源#  阿里源deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n\n清华源# 清华源deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n\n中科大源# 中科大源deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n\nubtuntu自带#deb cdrom:[Ubuntu 18.04 LTS _Bionic Beaver_ - Release amd64 (20180426)]/ bionic main restricted# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to# newer versions of the distribution.deb http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted# deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted## Major bug fix updates produced after the final release of the## distribution.deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted# deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team. Also, please note that software in universe WILL NOT receive any## review or updates from the Ubuntu security team.deb http://cn.archive.ubuntu.com/ubuntu/ bionic universe# deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic universedeb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates universe# deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates universe## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu ## team, and may not be under a free licence. Please satisfy yourself as to ## your rights to use the software. Also, please note that software in ## multiverse WILL NOT receive any review or updates from the Ubuntu## security team.deb http://cn.archive.ubuntu.com/ubuntu/ bionic multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic multiversedeb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-updates multiverse## N.B. software from this repository may not have been tested as## extensively as that contained in the main release, although it includes## newer versions of some applications which may provide useful features.## Also, please note that software in backports WILL NOT receive any review## or updates from the Ubuntu security team.deb http://cn.archive.ubuntu.com/ubuntu/ bionic-backports main restricted universe multiverse# deb-src http://cn.archive.ubuntu.com/ubuntu/ bionic-backports main restricted universe multiverse## Uncomment the following two lines to add software from Canonical&#x27;s## &#x27;partner&#x27; repository.## This software is not part of Ubuntu, but is offered by Canonical and the## respective vendors as a service to Ubuntu users.# deb http://archive.canonical.com/ubuntu bionic partner# deb-src http://archive.canonical.com/ubuntu bionic partnerdeb http://security.ubuntu.com/ubuntu bionic-security main restricted# deb-src http://security.ubuntu.com/ubuntu bionic-security main restricteddeb http://security.ubuntu.com/ubuntu bionic-security universe# deb-src http://security.ubuntu.com/ubuntu bionic-security universedeb http://security.ubuntu.com/ubuntu bionic-security multiverse# deb-src http://security.ubuntu.com/ubuntu bionic-security multiverse\n\n","categories":["Linux"],"tags":["ubuntu"]},{"title":"上下文实现","url":"/2023/07/17/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AE%9E%E7%8E%B0/","content":"public class UserContext &#123;\t//本地线程变量    private static final ThreadLocal&lt;Holder&gt; holder = ThreadLocal.withInitial(Holder::new);\t//正则匹配资源路径    private static final Pattern RESOURCE_URI_PATTERN = Pattern.compile(&quot;^/api/resource/.+$&quot;);\t@Data    public static class Holder &#123;        private User user;    &#125;        /**     * 设置当前用户     *     * @param user     */    public static void setCurrentUser(User user) &#123;        Holder holder = UserContext.holder.get();        holder.setUser(user);    &#125;    /**     * 获取当前用户     *     * @return     */    public static User getCurrentUser() &#123;        return holder.get().getUser();    &#125;    /**     * 判断当前用户的权限是否允许该资源     *     * @param authorityEnum 权限枚举     * @return     */    public static boolean permission(AuthorityEnum authorityEnum) &#123;     \t//检索对象是否为空        Objects.requireNonNull(authorityEnum, &quot;权限枚举不能为null&quot;);        User user = holder.get().getUser();        return user.getAuthority() == authorityEnum.getAuthority();    &#125;    public static boolean permission() &#123;        User user = holder.get().getUser();        return !Objects.equals(user.getAuthority(), AuthorityEnum.GENERAL_USER.getAuthority());    &#125;    public static void clear() &#123;    \t//删除对应value对象        holder.remove();    &#125;&#125;\n\n","categories":["SpringBoot"],"tags":["Java"]},{"title":"使用 GitHub Actions 云编译 OpenWrt","url":"/2023/05/21/%E4%BD%BF%E7%94%A8-GitHub-Actions-%E4%BA%91%E7%BC%96%E8%AF%91-OpenWrt/","content":"来源 https://p3terx.com/archives/build-openwrt-with-github-actions.html\n前言Github Ac­tions 是 Mi­crosoft 收购 GitHub 后推出的 CI&#x2F;CD 服务，它提供了性能配置非常不错的虚拟服务器环境（E5 2vCPU&#x2F;7G RAM），基于它可以进行构建、测试、打包、部署项目。对于公开仓库可免费无时间限制的使用，且单次使用时间长达 6 个小时，这对于编译 Open­Wrt 来说是非常充足的。不过 GitHub Ac­tions 有一定的使用门槛，首先要了解如何编写 workflow 文件。不过不用担心，博主已经编写好了相关的 work­flow 文件模版，只需要按照教程的步骤来操作即可。 \n教程更新\n2020-04-25 更新 DIY 脚本说明、添加自定义 feeds 配置文件说明\n2020-04-09 新增上传固件到 WeTransfer\n2020-03-30 新增上传固件到奶牛快传\n2020-02-01 新图文教程\n2019-12-10 新增 macOS 编译方案使用说明\n2019-12-06 添加 tmate 网页终端链接说明\n2019-12-05 优化基础使用教程，添加 @lietxia 大佬的图文教程链接\n2019-12-04 新增云menuconfig使用方法\n2019-12-03 新增并发编译使用方法\n2019-11-30 新增自定义源码编译使用方法\n2019-11-14 全网独家首发\n\n方案特点\n免费\n一键快速编译\n定时自动编译\n客制化编译\n并发编译（可同时进行20+5个编译任务）\n无需搭建编译环境（在线make menuconfig生成配置文件)\n无需消耗自己的计算机与服务器的计算资源（性感E5在线编译）\n无需担心磁盘空间不足（近60G磁盘空间）\n无需使用清理文件（内核更新不怕 boom ）\n编译速度快（编译时间1-2小时）\n编译成功率提升200%（万兆自由网络环境）\n全新环境（杜绝编译环境不干净导致编译失败）\n\n\n本解决方案是一个开放平台，任何人都可以基于此打造自己专属的编译方案。\n\n项目地址https://github.com/P3TERX/Actions-OpenWrt\n支持项目请随手点个 star，让更多的人发现、使用并受益。\n准备工作\n注册 GitHub 账号\n搭建编译环境，用于生成.config文件。(可选)\n\n\nTIPS: 关于编译环境的搭建，推荐去看我之前写的相关文章，Win­dows 10 可以使用 WSL ，ma­cOS、Linux 可以使用 Docker 。\n\n基础使用首先你必须要熟悉整个 Open­Wrt 的编译过程，这会让你非常容易的理解如何使用 GitHub Ac­tions 进行编译，即使你没有成功过。因为实际上本地编译近 90% 失败的原因是因为网络问题导致的，中国大陆特色，咱也不敢多说。而使用 GitHub Ac­tions 编译成功率至少提升 200% ，为什么这样说呢？因为 Ac­tions 服务器由 Mi­crosoft Azure 提供，在自由的美利坚，拥有万兆带宽。\n首次编译\n在自己搭建编译环境中使用 Lean’s OpenWrt 源码生成.config文件。（或使用后面进阶玩法中的云menuconfig，直接 SSH 到 Actions 进行操作）\n\n\nTIPS: 方案默认引用 Lean 的源码，因为他的 README 影响了我开始学习编译，也就有了这个项目，而且他的源码非常的优秀。有其它需求可自行修改 work­flow 文件，方法后面的进阶使用中有说明。\n\n\n进入 P3TERX&#x2F;Actions-OpenWrt 项目页面，点击页面中的 Use this template （使用这个模版）按钮。\n\n\n\n填写仓库名称，然后点击Create repository from template（从模版创建储存库）按钮。\n\n\n\n经过几秒钟的等待，页面会跳转到新建的仓库，内容和我的项目是相同的。然后点击Create new file（创建新文件）按钮。\n\n\n\n文件名填写为.config，把生成的.config 文件的内容复制粘贴到下面的文本框中。\n\n\n\n翻到页面最下方，点击Commit new file（提交新文件）按钮即可。后续编译工作会自动开始，你可以在 Actions 页面进行查看。\n\n\n\n在等待编译完成的过程中，你可以进入这个页面点击右上角的star，这是对博主最大的支持，而且还可以加快编译速度哦（雾\n最后经过一两个小时的等待，不出意外你就可以在 Actions 页面看到已经打包好的固件目录压缩包。\n\n\n\nTIPS: 如需 ipk 文件可以在进阶使用章节找到方法。因为大多数人只需要固件，而且总是有萌新问固件在哪，所以现在默认只上传固件。\n\n再次编译默认情况下触发编译工作流程有两种方式：\n\n发布 release\n修改.config文件\n\n他们分别对应以下使用场景：\n\n在编译配置没有修改的情况下，你发现大佬的仓库源码有更新，那么在 releases 页面发布一个 release 将直接触发编译的工作流程，使用最新源码进行编译。\n如果你想修改配置，则生成船新的.config文件 push 到仓库来触发编译的工作流程。\n\n其它触发方式你可以在后面的进阶使用中看到。\n进阶使用自定义环境变量与功能打开 work­flow 文件（.github/workflows/build-openwrt.yml），你会看到有如下一些环境变量，可按照自己的需求对这些变量进行定义。\nenv:  REPO_URL: https://github.com/coolsnowwolf/lede  REPO_BRANCH: master  FEEDS_CONF: feeds.conf.default  CONFIG_FILE: .config  DIY_P1_SH: diy-part1.sh  DIY_P2_SH: diy-part2.sh  SSH_ACTIONS: false  UPLOAD_BIN_DIR: false  UPLOAD_FIRMWARE: true  UPLOAD_COWTRANSFER: false  UPLOAD_WETRANSFER: false  TZ: Asia/Shanghai\n\n\nTIPS: 修改时需要注意:(冒号)后面有空格。\n\n\n\n\n环境变量\n功能\n\n\n\nREPO_URL\n源码仓库地址\n\n\nREPO_BRANCH\n源码分支\n\n\nFEEDS_CONF\n自定义feeds.conf.default文件名\n\n\nCONFIG_FILE\n自定义.config文件名\n\n\nDIY_P1_SH\n自定义diy-part1.sh文件名\n\n\nDIY_P2_SH\n自定义diy-part2.sh文件名\n\n\nSSH_ACTIONS\nSSH 连接 Actions 功能。默认false\n\n\nUPLOAD_BIN_DIR\n上传 bin 目录。即包含所有 ipk 文件和固件的目录。默认false\n\n\nUPLOAD_FIRMWARE\n上传固件目录。默认true\n\n\nUPLOAD_COWTRANSFER\n上传固件到奶牛快传。默认false\n\n\nUPLOAD_WERANSFER\n上传固件到 WeTransfer 。默认false\n\n\nTZ\n时区设置\n\n\nDIY 脚本仓库根目录目前有两个 DIY 脚本：diy-part1.sh 和 diy-part2.sh，它们分别在更新与安装 feeds 的前后执行，你可以把对源码修改的指令写到脚本中，比如修改默认 IP、主机名、主题、添加 &#x2F; 删除软件包等操作。但不仅限于这些操作，发挥你强大的想象力，可做出更强大的功能。\n\nTIPS: 脚本工作目录在源码目录，内附几个简单的例子供参考。\n\n添加额外的软件包\n在 DIY 脚本中加入对指定软件包源码的远程仓库的克隆指令。就像下面这样：\n\ngit clone https://github.com/P3TERX/xxx package/xxx\n\n\n本地make menuconfig生成.config文件时添加相应的软件包，如果你知道包名可以直接写到.config文件中。\n\n\nTIPS: 如果额外添加的软件包与 Open­Wrt 源码中已有的软件包同名的情况，则需要把 Open­Wrt 源码中的同名软件包删除，否则会优先编译 Open­Wrt 中的软件包。这同样可以利用到的 DIY 脚本，相关指令应写在diy-part2.sh。\n\n原理是把软件包源码放到 package 目录下，编译时会自动遍历，与本地编译是一样的。当然方法不止一种，其它方式请自行探索。\n自定义 feeds 配置文件把 feeds.conf.default 文件放入仓库根目录即可，它会覆盖 Open­Wrt 源码目录下的相关文件。\nCustom files（自定义文件）俗称 “files 大法”，在仓库根目录下新建 files 目录，把相关文件放入即可。有关详情请自行搜索了解。\n定时自动编译编辑 work­flow 文件（.github/workflows/build-openwrt.yml）取消注释下面两行。\n#  schedule:#    - cron: 0 8 * * 5\n\n例子是北京时间每周五下午 4 点（16 时）开始编译（周末下班回家直接下载最新固件开始折腾）。如需自定义则按照 cron 格式修改即可，GitHub Ac­tions 的时区为 UTC ，注意按照自己所在地时区进行转换。\n真·一键编译（点击 star 开始编译）点击自己仓库页面上的 Star 按钮开始编译，为了防止产生垃圾记录，所以这个功能默认没有开启。\n编辑 work­flow 文件（.github/workflows/build-openwrt.yml）取消注释下面两行，后续点击自己仓库上的 star 即可开始编译。\n#  watch:#    types: started\n\n\nTIPS: 字段started并不是“开始了”的意思，而是“已经点击 Star”。吐槽: 官方并没有提供一个开始按钮，通过搜索找到过很多奇怪的一键触发方式，但都是通过 Web­hook 来实现的。机智的我发现了可以通过点击 Star 来触发，这样就相当于把 Star 当成开始按钮。这个started有种一句双关的意思了。\n\n自定义源码编译此方案默认引用的是 Lean 的源码，如果你有编译其它源码的需求可以进行替换，自由是本解决方案最大的特点。\n编辑 work­flow 文件（.github/workflows/build-openwrt.yml），修改下面的相关环境变量字段。\nREPO_URL: https://github.com/coolsnowwolf/ledeREPO_BRANCH: master\n\n比如修改为 Open­Wrt 官方源码 19.07 分支\nREPO_URL: https://github.com/openwrt/openwrtREPO_BRANCH: openwrt-19.07\n\n\nTIPS: 注意冒号后面有空格\n\n并发编译（同时编译多个固件）多 repository 方案通过 P3TERX&#x2F;Actions-OpenWrt 项目创建多个仓库来编译不同架构机型的 Open­Wrt 固件。\n多 workflow 方案基于 GitHub Ac­tions 可同时运行多个工作流程的特性，最多可以同时进行至少 20 个编译任务。也可以单独选择其中一个进行编译，这充分的利用到了 GitHub Ac­tions 为每个账户免费提供的 20 个 Ubuntu 虚拟服务器环境。此外你还可以额外再使用 5 个 macOS 虚拟服务器环境进行编译，开启方法在后面有说明。\n假设有三台路由器的固件需要编译，比如 K2P、x86_64 软路由、新路由 3。\n\n生成它们的.config文件\n分别将它们重命名为k2p.config、x64.config、d2.config放入本地仓库根目录。\n复制多个 workflow 文件（.github/workflows/build-openwrt.yml）。为了更好的区分可以对它进行重命名，比如k2p.yml、x64.yml、d2.yml。此外第一行name字段也可以进行相应的修改。\n然后分别用上面修改的文件名替换对应 workflow 文件中下面两个位置的.config，不同的机型同样可以使用不同的 DIY 脚本。\n\n...    paths:      - &#x27;.config&#x27;...        CONFIG_FILE: &#x27;.config&#x27;        DIY_SH: &#x27;diy.sh&#x27;...\n\n\n最后 push ，此时此就触发了3个并行的编译工作流程。\n\n云 menuconfig（SSH 连接到 Actions）通过 tmate 连接到 GitHub Ac­tions 虚拟服务器环境，可直接进行 make menuconfig 操作生成编译配置，或者任意的客制化操作。也就是说，你不需要再自己搭建编译环境了。这可能改变之前所有使用 GitHub Ac­tions 的编译 Open­Wrt 方式。\n\n编辑 workflow 文件（.github/workflows/build-openwrt.yml），修改SSH_ACTIONS环境变量的值为true。（或者也可以不修改，而是通过 webhook 方式发送带有ssh触发关键词的请求。）\n\nSSH_ACTIONS: true\n\n\n在触发工作流程后，在 Actions 页面等待执行到SSH connection to Actions步骤，会出现下面的信息。\n\nTo connect to this session copy-n-paste the following into a terminal or browser:ssh Y26QeagDtsPXp2mT6me5cnMRd@nyc1.tmate.iohttps://tmate.io/t/Y26QeagDtsPXp2mT6me5cnMRd\n\n\n复制 SSH 连接命令粘贴到终端内执行，或者复制链接在浏览器中打开使用网页终端。（网页终端可能会遇到黑屏的情况，按 Ctrl + C 即可）\ncd openwrt &amp;&amp; make menuconfig\n完成后按快捷键Ctrl+D或执行exit命令退出，后续编译工作将自动进行。\n\n\nTIPS: 固件目录下有个config.seed文件，如果你需要再次编译可以使用它。WARRING: 默认连接30分钟后会断开并终止编译工作流程，防止资源浪费与封号风险。如果你想解除这个限制，可以根据提示操作，但导致的一切后果请自行承担。\n\nmacOS 虚拟机编译方案GitHub Ac­tions 的 ma­cOS 虚拟机性能要高于 Ubuntu 虚拟机，所以使用它编译 Open­Wrt 理论上速度会更快。博主经过几天时间的研究已经总结出了 macOS 下的 OpenWrt 编译环境的搭建方法，并编写出了适用于 ma­cOS 虚拟环境的 Open­Wrt 编译方案的 work­flow 文件。\n由于极少有开发者会考虑兼容 ma­cOS 下的规范，所以使用 ma­cOS 编译 Open­Wrt 不可避免的会遇到非常多的问题，甚至 Open­Wrt 官方源码也是。而且后续测试发现 ma­cOS 虚拟机性能已大幅下降，故相关 work­flow 文件已经移除。也不建议任何人使用 ma­cOS 编译 Open­Wrt 。\n上传固件到奶牛快传奶牛快传是中国大陆的一款临时文件传输分享服务网盘，特点是不限速。因国情所致，中国大陆地区 GitHub 访问速度缓慢，有些小伙伴可能无法正常下载固件，上传固件到奶牛快传是个非常好的选择。\n\n编辑 workflow 文件（.github/workflows/build-openwrt.yml），将环境变量UPLOAD_COWTRANSFER的值修改为true：\n\nUPLOAD_COWTRANSFER: true\n\n编译完成后你可以在 Upload firmware to cowtransfer 步骤的日志中找到下载链接。\n\nCLI 上传工具来自 Mikubill&#x2F;transfer ，特此感谢。\n\n上传固件到 WeTransferWeTransfer 是荷兰的一款临时文件传输分享服务网盘，前面提到的奶牛快传实际上师从自它，二者的网站都非常相似。We­Trans­fer 使用的是 Ama­zon S3 存储并通过 Ama­zon Cloud­Front CDN 全球加速，它在中国大陆的下载体验完全不输奶牛快传，甚至某些情况下要更好。\n\n编辑 workflow 文件（.github/workflows/build-openwrt.yml），将环境变量UPLOAD_WERANSFER的值修改为true：\n\nUPLOAD_WERANSFER: true\n\n编译完成后你可以在 Upload firmware to WeTransfer 步骤的日志中找到下载链接。\n\nCLI 上传工具来自 Mikubill&#x2F;transfer ，特此感谢。\n\n上传固件到 release不建议任何人发布并上传到 re­lease ，因为 re­lease 的文件是永久保存的，日积月累会给 GitHub 带来很多大的储存空间浪费。故不直接方法不提供方法，有能力且有正常需求的小伙伴请自行研究学习，相关问题不会解答。\n\n题外话：几年前博主曾亲眼目睹著名 An­droid 开源项目 Open GApps 正常发布但过于频繁导致直接封号。前一秒还在下载，后一秒仓库就没了。\n\n尾巴希望大家合理使用免费的资源，必要时再编译，过度占用资源虽然使用者不会得到任何实质性的惩罚，但会为中国抹黑，造成很多国际争端。只有让开发者来充分利用才能产生更多更好的软件，这样大家才能受益。最后感谢 Mi­crosoft 为我们提供 GitHub Ac­tions 这样强大的工具。\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; End\n","categories":["路由器"],"tags":["openwrt"]},{"title":"全局异常处理器","url":"/2023/07/24/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/","content":"@Slf4j@RestControllerAdvice(basePackages = &#123;&quot;info.wangyuan.enroll.controller&quot;, &quot;info.wangyuan.enroll.controller.admin&quot;&#125;)public class GlobalExceptionHandler &#123;    @ExceptionHandler(Throwable.class)    public Result elegantlyHandleException(HttpServletRequest request, Exception e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage(), e);            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        return Result.fail(StatusCodeEnum.UNKNOWN_ERROR);    &#125;    @ExceptionHandler(BusinessException.class)    public Result handleBusinessException(HttpServletRequest request, BusinessException e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage());            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        return Result.fail(e.getCode(), e.getMessage());    &#125;    @ExceptionHandler(BindException.class)    public Result handleBindException(HttpServletRequest request, BindException e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage());            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        StringJoiner messageJoiner = new StringJoiner(&quot;\\n&quot;);        e.getFieldErrors().stream().forEach(fieldError -&gt; &#123;            messageJoiner.add(fieldError.getDefaultMessage());        &#125;);        return Result.fail(StatusCodeEnum.PARAMETER_ERROR.getCode(), messageJoiner.toString());    &#125;    @ExceptionHandler(MethodArgumentNotValidException.class)    public Result handleMethodArgumentNotValidException(HttpServletRequest request, MethodArgumentNotValidException e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage());            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        StringJoiner messageJoiner = new StringJoiner(&quot;;&quot;);        e.getBindingResult().getFieldErrors().stream().forEach(fieldError -&gt; &#123;            messageJoiner.add(fieldError.getDefaultMessage());        &#125;);        return Result.fail(StatusCodeEnum.PARAMETER_ERROR.getCode(), messageJoiner.toString());    &#125;    @ExceptionHandler(HttpMessageNotReadableException.class)    public Result handleHttpMessageNotReadableException(HttpServletRequest request, HttpMessageNotReadableException e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage());            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        return Result.fail(StatusCodeEnum.PARAMETER_ERROR);    &#125;    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)    public Result handleHttpRequestMethodNotSupportedException(HttpServletRequest request, HttpRequestMethodNotSupportedException e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage());            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        return Result.fail(StatusCodeEnum.REQUEST_METHOD_NOT_SUPPORT);    &#125;    @ExceptionHandler(ConstraintViolationException.class)    public Result handleConstraintViolationException(HttpServletRequest request, ConstraintViolationException e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage());            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        StringBuilder sb = new StringBuilder();        Iterator&lt;ConstraintViolation&lt;?&gt;&gt; iterator = e.getConstraintViolations().iterator();        while (iterator.hasNext()) &#123;            ConstraintViolation&lt;?&gt; cv = iterator.next();            sb.append(cv.getMessage());            if (iterator.hasNext()) &#123;                sb.append(&quot;;&quot;);            &#125;        &#125;        return Result.fail(StatusCodeEnum.PARAMETER_ERROR.getCode(), sb.toString());    &#125;    @ExceptionHandler(MissingServletRequestParameterException.class)    public Result handleMissingServletRequestParameterException(HttpServletRequest request, MissingServletRequestParameterException e) &#123;        try &#123;            log.error(&quot;--------------- &#123;&#125; start ---------------&quot;, e.getClass().getSimpleName());            prettyPrintRequestInfo(request);            log.error(e.getMessage());            log.error(&quot;--------------- &#123;&#125; end ---------------&quot;, e.getClass().getSimpleName());        &#125; catch (Exception ex) &#123;            log.error(ex.getMessage(), ex);        &#125;        return Result.fail(StatusCodeEnum.PARAMETER_ERROR.getCode(), &quot;缺少参数: &quot; + e.getParameterName());    &#125;    /**     * 打印请求信息, 方便用于复查     *     * @param request     */    public void prettyPrintRequestInfo(HttpServletRequest request) &#123;        String requestURI = request.getRequestURI();        String method = request.getMethod();        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();        Map&lt;String, List&lt;String&gt;&gt; printedMap = convertToStringKeyAndListValue(parameterMap);        String contentType = request.getHeader(HttpHeaders.CONTENT_TYPE);        log.error(&quot;请求uri: &#123;&#125;&quot;, requestURI);        log.error(&quot;请求方法: &#123;&#125;&quot;, method);        log.error(&quot;请求参数: &#123;&#125;&quot;, printedMap);        log.error(&quot;请求头Content-Type: &#123;&#125;&quot;, contentType);    &#125;    private Map&lt;String, List&lt;String&gt;&gt; convertToStringKeyAndListValue(Map&lt;String, String[]&gt; parameterMap) &#123;        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(parameterMap.size());        parameterMap.forEach((key, value) -&gt; &#123;            map.put(key, Arrays.stream(value).map(this::truncateString).collect(Collectors.toList()));        &#125;);        return map;    &#125;    private String truncateString(String str) &#123;        if (str == null) &#123;            return null;        &#125; else if (str.length() &gt; 300) &#123;            return str.substring(0, 300);        &#125; else &#123;            return str;        &#125;    &#125;&#125;\n\n","categories":["SpringBoot"],"tags":["Java"]},{"title":"实现MySQL主从复制","url":"/2023/07/26/%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","content":"一、开启MySQL的binlog判断MySQL是否已经开启binlog\nSHOW VARIABLES LIKE &#x27;log_bin&#x27;;\n\n查看MySQL的binlog模式\nshow global variables like &quot;binlog%&quot;; #查看binlog_format字段\n\nbinlog常用的命令\n#查看日志开启状态 show variables like &#x27;log_%&#x27;;#查看所有binlog日志列表show master logs;#查看最新一个binlog日志的编号名称，及其最后一个操作事件结束点 show master status;#刷新log日志，立刻产生一个新编号的binlog日志文件，跟重启一个效果 flush logs;#清空所有binlog日志 reset master;#可以将二进制文件转为可阅读的sql语句。mysqlbinlog mysql-bin.000005恢复命令的语法格式：mysqlbinlog mysql-bin.0000xx | mysql -u用户名 -p密码 数据库名常用参数选项解释：    –start-position=875 起始pos点    –stop-position=954 结束pos点    –start-datetime=“2016-9-25 22:01:08” 起始时间点    –stop-datetime=“2019-9-25 22:09:46” 结束时间点    –database=xxx指定只恢复xxx数据库(一台主机上往往有多个数据库，只限本地log日志)\t实际是将读出的binlog日志内容，通过管道符传递给mysql命令。这些命令、文件尽量写成绝对路径；\n\n修改mysql的my.cnf配置文件一般默认是在/etc/my.cnf路径下\n在mysqld下添加\n#第一种方式:#开启binlog日志log_bin=ON#binlog日志的基本文件名log_bin_basename=/var/lib/mysql/mysql-bin#binlog文件的索引文件，管理所有binlog文件log_bin_index=/var/lib/mysql/mysql-bin.index#配置serveridserver-id=1#第二种方式:#此一行等同于上面log_bin三行,这里可以写绝对路径,也可以直接写mysql-bin(后者默认就是在/var/lib/mysql目录下)log-bin=/var/lib/mysql/mysql-bin#配置serveridserver-id=1\n\n修改完配置后，重启mysql。执行SHOW VARIABLES LIKE &#39;log_bin&#39;; Value 值为 ON即可。\n详细binlog的配置简介\n[mysqld]#设置日志三种格式：STATEMENT、ROW、MIXED 。binlog_format = mixed#设置日志路径，注意路经需要mysql用户有权限写,这里可以写绝对路径,也可以直接写mysql-bin(后者默认就是在/var/lib/mysql目录下)log-bin = /data/mysql/logs/mysql-bin.log#设置binlog清理时间expire_logs_days = 7#binlog每个日志文件大小max_binlog_size = 100m#binlog缓存大小binlog_cache_size = 4m#最大binlog缓存大小max_binlog_cache_size = 512m#配置serveridserver-id=1\n\n\nSTATMENT模式(默认)：基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。优点：不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。\n\n缺点：在某些情况下会导致master-slave中的数据不一致(比如：delete from t where a&gt;&#x3D;4 and t_modified&lt;&#x3D;’2018-11-10’ limit 1;在主库执行这个语句的时候，如果使用的是a索引，会删除(4,4,’2018-11-10’)这条记录，如果使用的是t_modified的索引则会删除(5,5,’2018-11-09’);所以在执行这条sql语句的时候提示： Unsafe statement written to the binary log using statement format since BINLOG_FORMAT &#x3D; STATEMENT. The statement is unsafe because it uses a LIMIT clause. This is unsafe because the set of rows included cannot be predicted.由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 t_modified。因此，MySQL认为这样写是有风险的。 sleep()函数， last_insert_id()，以及user-definedfunctions(udf)等也会出现问题)；\n\nROW:&#96;&#96;基于行的复制(row-based replication, RBR)格式：不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了。优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨。\n\nMIXED:&#96;&#96;混合模式复制(mixed-based replication, MBR)：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。\n\n\n二、配置主库更改&#x2F;etc&#x2F;my.cnf，在[mysqld]下加入\n#mysql服务id，取值在1到2的32次方减一，默认为1server-id=1#表示是否只读，1为只读，0为读写read-only=0\n\n创建拥有主从复制权限的账户\n# &#x27;%&#x27;表示允许任意主机连接，mysql_native_password为mysql的一个身份认证插件create user &#x27;用户名&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;密码&#x27;#分配主从复制权限,ON *.*子句表示MySQL中的所有数据库和所有对象。grant replication slave on *.* to &#x27;用户名&#x27;@&#x27;%&#x27;\n\n然后重启mysql\n查看binlog文件坐标\nshow master status\n\n\n\n\nFile\nPosition\nBinlog_Do_DB\nBinlog_Ignore_DB\nExecuted_Gtid_Set\n\n\n\nmysql-bin.000001\n1361\n\nmysql\n\n\n\n三、配置从库更改从库&#x2F;etc&#x2F;my.cnf，在[mysqld]下加入\n#mysql服务id，取值在1到2的32次方减一，默认为1server-id=2#表示是否只读，1为只读，0为读写read-only=1#super-read-only=1表示超级管理员是否读写\n\n重启mysql\n登入从库mysql，执行命令\nmysql8.0.23语法\nchange replication source to SOURCE_HOST=&#x27;主库IP地址&#x27;,SOURCE_PORT=主库端口号,SOURCE_USER=&#x27;主库开启主从复制权限的用户&#x27;,SOURCE_PASSWORD=&#x27;密码&#x27;,SOURCE_LOG_FILE=&#x27;binlog文件名&#x27;,SOURCE_LOG_POS=1361\n\nmysql8.0.23之前的版本\nchange master to master_host=&#x27;主库IP地址&#x27;,master_port=主库端口号,master_user =&#x27;主库开启主从复制权限的用户&#x27;,master_password =&#x27;密码&#x27;,master_log_file =&#x27;binlog文件名&#x27;,master_log_pos = 1361\n\n_log_file和_log_pos通过show master status命令查看\n四、开启同步start replica; #8.0.22之后start slave; #8.0.22之前\n\n五、查看主从同步状态show replica status; #8.0.22之后show slave status; #8.0.22之前\n\n","categories":["数据库"],"tags":["mysql"]},{"title":"利用LEDE编译自己的OPENWRT固件","url":"/2023/05/21/%E5%88%A9%E7%94%A8LEDE%E7%BC%96%E8%AF%91%E8%87%AA%E5%B7%B1%E7%9A%84OPENWRT%E5%9B%BA%E4%BB%B6/","content":"自己经常做软路由玩，当然一些硬件路由也是可以的，只要芯片被支持就可以。\n一.编译环境\n​    一般选用ubuntu系统，我选用的是ubuntu18.04服务器版，在本地系统上还需要搭梯子，有好多库和软件需要从国外的资源上拉。\n   我用免费申请的谷歌云服务器上编译，就不存在这个问题（不过访问谷歌云服务也是需要梯子的，只是编译的时候由于在服务器上，相对比较稳定，不容易出错） \n二.登录云主机后，做好相应的更新\n注意：1. 不要用 root 用户 git 和编译！！！2. 国内用户编译前最好准备好梯子3. 默认登陆IP 192.168.1.1, 密码 password编译命令如下:1. 首先装好 Ubuntu 64bit，推荐  Ubuntu  14 LTS x642. 命令行输入 sudo apt-get update ，然后输入sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler3. git clone https://github.com/coolsnowwolf/lede 命令下载好源代码，然后 cd lede 进入目录4. ./scripts/feeds update -a    ./scripts/feeds install -a   make menuconfig \n\n\n\n\n\n具体说明如下图\n\n表格****使用说明：make menuconfig直接参照表格选择即可，选项按颜色设定白色字体项可以不选，为附加功能，按需选择黑色字体项在配置里部分项默认选中，带标注的按需选择，未带标注的请选中黄色字体项必选红色字体项为二选一(功能冲突项)红框项为不选Luci通过照下面的表按需选择\n编译X86的软路由前面基本不用设置，如果是硬件路由全面3项要选择相应的系统，芯片和产品型号\n后面就是luci插件的选择，也是自己编译固件的重点部分，原则上需要什么功能就选择什么功能，各种插件对应的功能看下表\n\n\n\nOpenWrt 编译 LuCI 插件说明\n\n\n\n\n\n\nLuCI\nApplications\nluci-app-accesscontrol\n访问时间控制\n\n\nLuCI\nApplications\nluci-app-adblock\nADB广告过滤\n\n\nLuCI\nApplications\nluci-app-adbyby-plus\n广告屏蔽大师Plus +\n\n\nLuCI\nApplications\nluci-app-adbyby\n广告过滤大师（已弃）\n\n\nLuCI\nApplications\nluci-app-adkill\n广告过滤（已弃）\n\n\nLuCI\nApplications\nluci-app-advanced-reboot\nLinksys高级重启\n\n\nLuCI\nApplications\nluci-app-ahcp\n支持AHCPd\n\n\nLuCI\nApplications\nluci-app-aliddns\n阿里DDNS客户端（已弃，集成至ddns）\n\n\nLuCI\nApplications\nluci-app-amule\naMule是一个跨平台的ED2K&#x2F;KAD客户端  P2P电驴下载\n\n\nLuCI\nApplications\nluci-app-aria2\nAria2下载\n\n\nLuCI\nApplications\nluci-app-arpbind\nIP&#x2F;MAC绑定\n\n\nLuCI\nApplications\nluci-app-asterisk\n支持Asterisk电话服务器\n\n\nLuCI\nApplications\nluci-app-attendedsysupgrade\n固件更新升级相关\n\n\nLuCI\nApplications\nluci-app-autoreboot\n支持计划重启\n\n\nLuCI\nApplications\nluci-app-baidupcs-web\n百度网盘管理\n\n\nLuCI\nApplications\nluci-app-bcp38\nBCP38网络入口过滤(不确定)\n\n\nLuCI\nApplications\nluci-app-bird1-ipv4\n对Birdl-ipv4的支持\n\n\nLuCI\nApplications\nluci-app-bird1-ipv6\n对Birdl-ipv6的支持\n\n\nLuCI\nApplications\nluci-app-bird4\nBird4服务(未知)\n\n\nLuCI\nApplications\nluci-app-bird6\nBird6服务(未知)\n\n\nLuCI\nApplications\nluci-app-bmx6\nBMX6路由协议\n\n\nLuCI\nApplications\nluci-app-bmx7\nBMX7路由协议\n\n\nLuCI\nApplications\nluci-app-caldav\n联系人\n\n\nLuCI\nApplications\nluci-app-cifsd\n网络共享CIFS&#x2F;SMB服务器\n\n\nLuCI\nApplications\nluci-app-cjdns\n加密IPV6网络相关\n\n\nLuCI\nApplications\nluci-app-clamav\nClamAV杀毒软件\n\n\nLuCI\nApplications\nluci-app-commands\nShell命令模块\n\n\nLuCI\nApplications\nluci-app-cshark\nCloudShark捕获工具\n\n\nLuCI\nApplications\nluci-app-ddns\n动态域名 DNS （集成阿里DDNS客户端）\n\n\nLuCI\nApplications\nluci-app-diag-core\ncore诊断工具\n\n\nLuCI\nApplications\nluci-app-dnscrypt-proxy\nDNSCrypt解决DNS污染\n\n\nLuCI\nApplications\nluci-app-dnsforwarder\nDNSForwarder防DNS污染\n\n\nLuCI\nApplications\nluci-app-dnspod\nDNSPod\n\n\nLuCI\nApplications\nluci-app-dockerman\nDocker容器\n\n\nLuCI\nApplications\nluci-app-dump1090\n民航无线频率(不确定)\n\n\nLuCI\nApplications\nluci-app-dynapoint\nDynaPoint(未知)\n\n\nLuCI\nApplications\nluci-app-e2guardian\nWeb内容过滤器\n\n\nLuCI\nApplications\nluci-app-familycloud\n家庭云盘\n\n\nLuCI\nApplications\nluci-app-filetransfer\n文件传输\n\n\nLuCI\nApplications\nluci-app-firewall\n添加防火墙\n\n\nLuCI\nApplications\nluci-app-flowoffload\nTurbo ACC 网络加速（集成FLOW,BBR,NAT,DNS…\n\n\nLuCI\nApplications\nluci-app-freifunk-diagnostics\nfreifunk组件 诊断(未知)\n\n\nLuCI\nApplications\nluci-app-freifunk-policyrouting\nfreifunk组件 策略路由(未知)\n\n\nLuCI\nApplications\nluci-app-freifunk-widgets\nfreifunk组件 Widgets(未知)\n\n\nLuCI\nApplications\nluci-app-frpc\n内网穿透 Frp\n\n\nLuCI\nApplications\nluci-app-fwknopd\nFirewall Knock Operator服务器\n\n\nLuCI\nApplications\nluci-app-guest-wifi\nWiFi访客网络\n\n\nLuCI\nApplications\nluci-app-gfwlist\nGFW域名列表（已弃）\n\n\nLuCI\nApplications\nluci-app-haproxy-tcp\nHAProxy负载均衡-TCP\n\n\nLuCI\nApplications\nluci-app-hd-idle\n硬盘休眠\n\n\nLuCI\nApplications\nluci-app-hnet\nHomenet Status家庭网络控制协议\n\n\nLuCI\nApplications\nluci-app-ipsec-vpnd\nVPN服务器 IPSec\n\n\nLuCI\nApplications\nluci-app-kodexplorer\nKOD可道云私人网盘\n\n\nLuCI\nApplications\nluci-app-kooldns\nVPN服务器 ddns替代方案\n\n\nLuCI\nApplications\nluci-app-koolproxy\nKP去广告\n\n\nLuCI\nApplications\nluci-app-lxc\nLXC容器管理\n\n\nLuCI\nApplications\nluci-app-meshwizard\n网络设置向导\n\n\nLuCI\nApplications\nluci-app-minidlna\n完全兼容DLNA &#x2F; UPnP-AV客户端的服务器软件\n\n\nLuCI\nApplications\nluci-app-mjpg-streamer\n兼容Linux-UVC的摄像头程序\n\n\nLuCI\nApplications\nluci-app-mtwifi\nMTWiFi驱动的支持\n\n\nLuCI\nApplications\nluci-app-mmc-over-gpio\n添加SD卡操作界面\n\n\nLuCI\nApplications\nluci-app-multiwan\n多拨虚拟网卡（已弃）\n\n\nLuCI\nApplications\nluci-app-mwan3\nMWAN负载均衡\n\n\nLuCI\nApplications\nluci-app-mwan3helper\nMWAN3分流助手\n\n\nLuCI\nApplications\nluci-app-n2n_v2\nN2N 内网穿透 N2N v2 VPN服务\n\n\nLuCI\nApplications\nluci-app-netdata\nNetdata实时监控（图表）\n\n\nLuCI\nApplications\nluci-app-nft-qos\nQOS流控 Nftables版\n\n\nLuCI\nApplications\nluci-app-ngrokc\nNgrok 内网穿透\n\n\nLuCI\nApplications\nluci-app-nlbwmon\n网络带宽监视器\n\n\nLuCI\nApplications\nluci-app-noddos\nNodDOS Clients 阻止DDoS攻击\n\n\nLuCI\nApplications\nluci-app-nps\n内网穿透nps\n\n\nLuCI\nApplications\nluci-app-ntpc\nNTP时间同步服务器\n\n\nLuCI\nApplications\nluci-app-ocserv\nOpenConnect VPN服务\n\n\nLuCI\nApplications\nluci-app-olsr\nOLSR配置和状态模块\n\n\nLuCI\nApplications\nluci-app-olsr-services\nOLSR服务器\n\n\nLuCI\nApplications\nluci-app-olsr-viz\nOLSR可视化\n\n\nLuCI\nApplications\nluci-app-ocserv\nOpenConnect VPN服务（已弃）\n\n\nLuCI\nApplications\nluci-app-openvpn\nOpenVPN客户端\n\n\nLuCI\nApplications\nluci-app-openvpn-server\n易于使用的 OpenVPN 服务器 Web-UI\n\n\nLuCI\nApplications\nluci-app-oscam\nOSCAM服务器\n\n\nLuCI\nApplications\nluci-app-p910nd\n打印服务器模块\n\n\nLuCI\nApplications\nluci-app-pagekitec\nPagekite 内网穿透客户端\n\n\nLuCI\nApplications\nluci-app-polipo\nPolipo代理（是一个小型且快速的网页缓存代理）\n\n\nLuCI\nApplications\nluci-app-pppoe-relay\nPPPoE NAT穿透 点对点协议（PPP）\n\n\nLuCI\nApplications\nluci-app-pptp-server\nVPN服务器 PPTP\n\n\nLuCI\nApplications\nluci-app-privoxy\nPrivoxy网络代理（带过滤无缓存）\n\n\nLuCI\nApplications\nluci-app-qbittorrent\nBT下载工具（qBittorrent）\n\n\nLuCI\nApplications\nluci-app-qos\n流量服务质量(QoS)流控\n\n\nLuCI\nApplications\nluci-app-radicale\nCalDAV&#x2F;CardDAV同步工具\n\n\nLuCI\nApplications\nluci-app-ramfree\n释放内存\n\n\nLuCI\nApplications\nluci-app-rp-pppoe-server\nRoaring Penguin PPPoE Server 服务器\n\n\nLuCI\nApplications\nluci-app-samba\n网络共享(samba)\n\n\nLuCI\nApplications\nluci-app-samba4\n网络共享(samba4)\n\n\nLuCI\nApplications\nluci-app-sfe\nTurbo ACC 网络加速（集成FLOW,BBR,NAT,DNS…\n\n\nLuCI\nApplications\nluci-app-shadowsocks\n科学上网\n\n\nLuCI\nApplications\nluci-app-shadowsocks-libev\nSS-libev服务端\n\n\nLuCI\nApplications\nluci-app-shairplay\n支持AirPlay功能\n\n\nLuCI\nApplications\nluci-app-siitwizard\nSIIT配置向导  SIIT-Wizzard\n\n\nLuCI\nApplications\nluci-app-simple-adblock\n简单的广告拦截\n\n\nLuCI\nApplications\nluci-app-smartdns\nSmartDNS本地服务器\n\n\nLuCI\nApplications\nluci-app-softethervpn\nSoftEther VPN服务器  NAT穿透\n\n\nLuCI\nApplications\nluci-app-splash\nClient-Splash是无线MESH网络的一个热点认证系统\n\n\nLuCI\nApplications\nluci-app-sqm\n流量智能队列管理(QOS)\n\n\nLuCI\nApplications\nluci-app-squid\nSquid代理服务器\n\n\nLuCI\nApplications\nluci-app-ssr-plus\nSSR科学上网Plus+\n\n\nluci-app-ssr-plus\nInclude Shadowsocks New Versiong\n新SS代理\n\n\n\nInclude Shadowsocks Simple-obfs Plugin\nSS simple-obfs简单混淆工具\n\n\n\n\nInclude Shadowsocks V2ray Plugin\nSS V2ray插件\n\n\n\n\nInclude V2ray\nV2Ray代理\n\n\n\n\nInclude Trojan\nTrojan代理\n\n\n\n\nInclude Kcptun\nKcptun代理\n\n\n\n\nInclude ShadowsocksR Server\nSSR服务器\n\n\n\n\nInclude Socks Server\nsocks代理服务器\n\n\n\n\nInclude ShadowsocksR Socks and Tunnel\nSSR代理\n\n\n\n\nLuCI\nApplications\nluci-app-ssr-pro\nSSR科学上网pro\n\n\nLuCI\nApplications\nluci-app-ssrserver-python\nShadowsocksR Python服务器\n\n\nLuCI\nApplications\nluci-app-statistics\n流量监控工具\n\n\nLuCI\nApplications\nluci-app-syncdial\n多拨虚拟WAN(原macvlan)\n\n\nLuCI\nApplications\nluci-app-tinyproxy\nTinyproxy是 HTTP(S)代理服务器\n\n\nLuCI\nApplications\nluci-app-transmission\nBT下载工具\n\n\nLuCI\nApplications\nluci-app-travelmate\n旅行路由器\n\n\nLuCI\nApplications\nluci-app-ttyd\n网页终端命令行\n\n\nLuCI\nApplications\nluci-app-udpxy\nudpxy做组播服务器\n\n\nLuCI\nApplications\nluci-app-uhttpd\nuHTTPd Web服务器\n\n\nLuCI\nApplications\nluci-app-unblockmusic\n解锁网易云灰色歌曲\n\n\nLuCI\nApplications\nluci-app-unblockneteasemusic-go\n解锁网易云歌曲\n\n\nLuCI\nApplications\nluci-app-unbound\nUnbound DNS解析器\n\n\nLuCI\nApplications\nluci-app-upnp\n通用即插即用UPnP(端口自动转发)\n\n\nLuCI\nApplications\nluci-app-usb-printer\nUSB 打印服务器\n\n\nLuCI\nApplications\nluci-app-v2ray-server\nV2Ray 服务器\n\n\nLuCI\nApplications\nluci-app-v2ray-pro\nV2Ray透明代理(已弃，集成SSR)\n\n\nLuCI\nApplications\nluci-app-v2ray-verysync\n微力同步\n\n\nLuCI\nApplications\nluci-app-vlmcsd\nKMS服务器（激活工具）\n\n\nLuCI\nApplications\nluci-app-vnstat\nvnStat网络监控（图表）\n\n\nLuCI\nApplications\nluci-app-vpnbypass\nVPN BypassWebUI  绕过VPN设置\n\n\nLuCI\nApplications\nluci-app-vsftpd\nFTP服务器\n\n\nLuCI\nApplications\nluci-app-watchcat\n断网检测功能与定时重启\n\n\nLuCI\nApplications\nluci-app-webadmin\nWeb管理页面设置\n\n\nLuCI\nApplications\nluci-app-webshell\n网页命令行终端\n\n\nLuCI\nApplications\nluci-app-wifischedule\nWiFi 计划\n\n\nLuCI\nApplications\nluci-app-wireguard\nVPN服务器 WireGuard状态\n\n\nLuCI\nApplications\nluci-app-wireless-regdb\nWiFi无线\n\n\nLuCI\nApplications\nluci-app-wol\nWOL网络唤醒\n\n\nLuCI\nApplications\nluci-app-wrtbwmon\n实时流量监测\n\n\nLuCI\nApplications\nluci-app-xlnetacc\n迅雷快鸟\n\n\nLuCI\nApplications\nluci-app-zerotier\n内网穿透 ZeroTier\n\n\nLuCI\nApplications\nluci-app-luci-i18n-chinese\n添加luci的中文语言包\n\n\nPS：根据群友分享文件改EXCEL版方便标注编译时选择适合自己的插件，新手用的，有不对之处请诸位大神帮忙改进！\n\n\n\n\n\n及时更新链接：\nhttps://www.right.com.cn/forum/thread-344825-1-1.html\n\n\n\n\n选择LuCI 配置 添加插件应用：常用-—————————————————————————————-LuCI —&gt; Applications —&gt; luci-app-accesscontrol  #访问时间控制LuCI —&gt; Applications —&gt; luci-app-adbyby-plus   #广告屏蔽大师Plus +LuCI —&gt; Applications —&gt; luci-app-arpbind  #IP&#x2F;MAC绑定LuCI —&gt; Applications —&gt; luci-app-autoreboot  #支持计划重启LuCI —&gt; Applications —&gt; luci-app-ddns   #动态域名 DNS（集成阿里DDNS客户端）LuCI —&gt; Applications —&gt; luci-app-filetransfer  #文件传输（可web安装ipk包）LuCI —&gt; Applications —&gt; luci-app-firewall   #添加防火墙LuCI —&gt; Applications —&gt; luci-app-flowoffload  #Turbo ACC网络加速（集成FLOW,BBR,NAT,DNS…LuCI —&gt; Applications —&gt; luci-app-frpc   #内网穿透 FrpLuCI —&gt; Applications —&gt; luci-app-guest-wifi  #WiFi访客网络LuCI —&gt; Applications —&gt; luci-app-ipsec-virtuald  #virtual服务器 IPSecLuCI —&gt; Applications —&gt; luci-app-mwan3   #MWAN3负载均衡LuCI —&gt; Applications —&gt; luci-app-mwan3helper   #MWAN3分流助手LuCI —&gt; Applications —&gt; luci-app-nlbwmon   #网络带宽监视器LuCI —&gt; Applications —&gt; luci-app-p p t p-server  #virtual**服务器 p p t pLuCI —&gt; Applications —&gt; luci-app-ramfree  #释放内存LuCI —&gt; Applications —&gt; luci-app-samba   #网络共享（Samba）LuCI —&gt; Applications —&gt; luci-app-sqm  #流量智能队列管理（QOS）-——————————————————————————————LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus   #乳酸菌饮料兲朝上网Plus+LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include s-s New Versiong  #新SS代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include s-s Simple-obfs Plugin  #simple-obfs简单混淆工具   *LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include s-s v贰瑞 Plugin  #SS v贰瑞插件   *LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include v贰瑞  #v贰瑞代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include Trojan  #Trojan代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include Kcptun  #Kcptun代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include 违禁软件 Server  #乳酸菌饮料服务器LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include Socks Server  #socks代理服务器   *-——————————————————————————————LuCI —&gt; Applications —&gt; luci-app-syncdial  #多拨虚拟网卡（原macvlan）LuCI —&gt; Applications —&gt; luci-app-unblockmusic  #解锁网易云灰色歌曲LuCI —&gt; Applications —&gt; luci-app-upnp   #通用即插即用UPnP（端口自动转发）LuCI —&gt; Applications —&gt; luci-app-vlmcsd  #KMS服务器设置LuCI —&gt; Applications —&gt; luci-app-vsftpd  #FTP服务器LuCI —&gt; Applications —&gt; luci-app-wifischedule  #WiFi 计划LuCI —&gt; Applications —&gt; luci-app-wirele违禁软件egdb  #WiFi无线LuCI —&gt; Applications —&gt; luci-app-wol   #WOL网络唤醒LuCI —&gt; Applications —&gt; luci-app-wrtbwmon  #实时流量监测LuCI —&gt; Applications —&gt; luci-app-xlnetacc  #迅雷快鸟LuCI —&gt; Applications —&gt; luci-app-zerotier  #ZeroTier内网穿透Extra packages  —&gt;  ipv6helper  #支持 ipv6\n以下是全部：                               注：应用后面标记 “ ***** ” 为最近新添加-—————————————————————————————-LuCI —&gt; Applications —&gt; luci-app-accesscontrol  #访问时间控制LuCI —&gt; Applications —&gt; luci-app-acme  #ACME 自动化证书管理环境LuCI —&gt; Applications —&gt; luci-app-adblock   #ADB广告过滤LuCI —&gt; Applications —&gt; luci-app-adbyby-plus  #广告屏蔽大师Plus +LuCI —&gt; Applications —&gt; luci-app-adbyby   #广告过滤大师（已弃）LuCI —&gt; Applications —&gt; luci-app-adkill   #广告过滤（已弃）LuCI —&gt; Applications —&gt; luci-app-advanced-reboot  #Linksys高级重启LuCI —&gt; Applications —&gt; luci-app-ahcp  #支持AHCPdLuCI —&gt; Applications —&gt; luci-app-aliddns   #阿里DDNS客户端（已弃，集成至ddns）LuCI —&gt; Applications —&gt; luci-app-amule  #aMule下载工具LuCI —&gt; Applications —&gt; luci-app-aria2 # Aria2下载工具LuCI —&gt; Applications —&gt; luci-app-arpbind  #IP&#x2F;MAC绑定LuCI —&gt; Applications —&gt; luci-app-asterisk  #支持Asterisk电话服务器LuCI —&gt; Applications —&gt; luci-app-attendedsysupgrade  #固件更新升级相关LuCI —&gt; Applications —&gt; luci-app-autoreboot  #支持计划重启LuCI —&gt; Applications —&gt; luci-app-baidupcs-web  #百度网盘管理   *LuCI —&gt; Applications —&gt; luci-app-bcp38  #BCP38网络入口过滤（不确定）LuCI —&gt; Applications —&gt; luci-app-bird1-ipv4  #对Bird1-ipv4的支持LuCI —&gt; Applications —&gt; luci-app-bird1-ipv6  #对Bird1-ipv6的支持LuCI —&gt; Applications —&gt; luci-app-bird4   #Bird 4（未知）（已弃）LuCI —&gt; Applications —&gt; luci-app-bird6   #Bird 6（未知）（已弃）LuCI —&gt; Applications —&gt; luci-app-bmx6  #BMX6路由协议LuCI —&gt; Applications —&gt; luci-app-bmx7  #BMX7路由协议LuCI —&gt; Applications —&gt; luci-app-caldav  #联系人（已弃）LuCI —&gt; Applications —&gt; luci-app-cifsd  #网络共享CIFS&#x2F;SMB服务器   *LuCI —&gt; Applications —&gt; luci-app-cjdns  #加密IPV6网络相关LuCI —&gt; Applications —&gt; luci-app-clamav  #ClamAV杀毒软件LuCI —&gt; Applications —&gt; luci-app-commands   #Shell命令模块LuCI —&gt; Applications —&gt; luci-app-cshark   #CloudShark捕获工具LuCI —&gt; Applications —&gt; luci-app-ddns   #动态域名 DNS（集成阿里DDNS客户端）LuCI —&gt; Applications —&gt; luci-app-diag-core   #core诊断工具LuCI —&gt; Applications —&gt; luci-app-dnscrypt-proxy  #DNSCrypt解决DNS污染LuCI —&gt; Applications —&gt; luci-app-dnsforwarder  #DNSForwarder防DNS污染LuCI —&gt; Applications —&gt; luci-app-dnspod  #DNSPod动态域名解析LuCI —&gt; Applications —&gt; luci-app-dockerman  #Docker容器   *LuCI —&gt; Applications —&gt; luci-app-dump1090  #民航无线频率（不确定）LuCI —&gt; Applications —&gt; luci-app-dynapoint  #DynaPoint（未知）LuCI —&gt; Applications —&gt; luci-app-e2guardian   #Web内容过滤器LuCI —&gt; Applications —&gt; luci-app-familycloud   #家庭云盘LuCI —&gt; Applications —&gt; luci-app-filetransfer  #文件传输（可web安装ipk包）LuCI —&gt; Applications —&gt; luci-app-firewall   #添加防火墙LuCI —&gt; Applications —&gt; luci-app-flowoffload  #Turbo ACC网络加速（集成FLOW,BBR,NAT,DNS…LuCI —&gt; Applications —&gt; luci-app-freifunk-diagnostics   #freifunk组件 诊断（未知）LuCI —&gt; Applications —&gt; luci-app-freifunk-policyrouting  #freifunk组件 策略路由（未知）LuCI —&gt; Applications —&gt; luci-app-freifunk-widgets  #freifunk组件 索引（未知）LuCI —&gt; Applications —&gt; luci-app-frpc   #内网穿透 FrpLuCI —&gt; Applications —&gt; luci-app-fwknopd  #Firewall Knock Operator服务器LuCI —&gt; Applications —&gt; luci-app-guest-wifi   #WiFi访客网络LuCI —&gt; Applications —&gt; luci-app-gfwlist   #GFW域名列表（已弃）LuCI —&gt; Applications —&gt; luci-app-haproxy-tcp   #HAProxy负载均衡-TCPLuCI —&gt; Applications —&gt; luci-app-hd-idle  #硬盘休眠LuCI —&gt; Applications —&gt; luci-app-hnet  #Homenet Status家庭网络控制协议LuCI —&gt; Applications —&gt; luci-app-ipsec-virtuald  #virtual服务器 IPSecLuCI —&gt; Applications —&gt; luci-app-kodexplorer  #KOD可道云私人网盘LuCI —&gt; Applications —&gt; luci-app-kooldns  #virtual服务器 ddns替代方案（已弃）LuCI —&gt; Applications —&gt; luci-app-koolproxy  #KP去广告（已弃）LuCI —&gt; Applications —&gt; luci-app-lxc   #LXC容器管理LuCI —&gt; Applications —&gt; luci-app-meshwizard #网络设置向导LuCI —&gt; Applications —&gt; luci-app-minidlna   #完全兼容DLNA &#x2F; UPnP-AV客户端的服务器软件LuCI —&gt; Applications —&gt; luci-app-mjpg-streamer   #兼容Linux-UVC的摄像头程序LuCI —&gt; Applications —&gt; luci-app-mtwifi  #MTWiFi驱动的支持   *LuCI —&gt; Applications —&gt; luci-app-mmc-over-gpio   #添加SD卡操作界面（已弃）LuCI —&gt; Applications —&gt; luci-app-multiwan   #多拨虚拟网卡（已弃，移至syncdial）LuCI —&gt; Applications —&gt; luci-app-mwan   #MWAN负载均衡（已弃）LuCI —&gt; Applications —&gt; luci-app-mwan3   #MWAN3负载均衡LuCI —&gt; Applications —&gt; luci-app-mwan3helper   #MWAN3分流助手LuCI —&gt; Applications —&gt; luci-app-n2n_v2   #N2N内网穿透 N2N v2 virtual服务LuCI —&gt; Applications —&gt; luci-app-netdata  #Netdata实时监控（图表）   *LuCI —&gt; Applications —&gt; luci-app-nft-qos  #QOS流控 Nftables版LuCI —&gt; Applications —&gt; luci-app-ngrokc  #Ngrok 内网穿透（已弃）LuCI —&gt; Applications —&gt; luci-app-nlbwmon   #网络带宽监视器LuCI —&gt; Applications —&gt; luci-app-noddos  #NodDOS Clients 阻止DDoS攻击LuCI —&gt; Applications —&gt; luci-app-nps  #内网穿透nps   *LuCI —&gt; Applications —&gt; luci-app-ntpc   #NTP时间同步服务器LuCI —&gt; Applications —&gt; luci-app-ocserv  #OpenConnect virtual服务LuCI —&gt; Applications —&gt; luci-app-olsr  #OLSR配置和状态模块LuCI —&gt; Applications —&gt; luci-app-olsr-services  #OLSR服务器LuCI —&gt; Applications —&gt; luci-app-olsr-viz   #OLSR可视化LuCI —&gt; Applications —&gt; luci-app-openvirtual  #Openvirtual客户端LuCI —&gt; Applications —&gt; luci-app-openvirtual-server  #易于使用的Openvirtual服务器 Web-UILuCI —&gt; Applications —&gt; luci-app-oscam   #OSCAM服务器（已弃）LuCI —&gt; Applications —&gt; luci-app-p910nd   #打印服务器模块LuCI —&gt; Applications —&gt; luci-app-pagekitec   #Pagekite内网穿透客户端LuCI —&gt; Applications —&gt; luci-app-polipo  #Polipo代理(是一个小型且快速的网页缓存代理)LuCI —&gt; Applications —&gt; luci-app-pppoe-relay  #PPPoE NAT穿透 点对点协议（PPP）LuCI —&gt; Applications —&gt; luci-app-p p t p-server  #virtual服务器 p p t pLuCI —&gt; Applications —&gt; luci-app-privoxy  #Privoxy网络代理(带过滤无缓存)LuCI —&gt; Applications —&gt; luci-app-qbittorrent  #BT下载工具（qBittorrent）LuCI —&gt; Applications —&gt; luci-app-qos   #流量服务质量(QoS)流控LuCI —&gt; Applications —&gt; luci-app-radicale   #CalDAV&#x2F;CardDAV同步工具LuCI —&gt; Applications —&gt; luci-app-ramfree  #释放内存LuCI —&gt; Applications —&gt; luci-app-rp-pppoe-server  #Roaring Penguin PPPoE Server 服务器LuCI —&gt; Applications —&gt; luci-app-samba   #网络共享（Samba）LuCI —&gt; Applications —&gt; luci-app-samba4   #网络共享（Samba4）LuCI —&gt; Applications —&gt; luci-app-sfe  #Turbo ACC网络加速（flowoffload二选一）LuCI —&gt; Applications —&gt; luci-app-s-s   #SS兲朝上网（已弃）LuCI —&gt; Applications —&gt; luci-app-s-s-libes  #SS-libev服务端LuCI —&gt; Applications —&gt; luci-app-shairplay  #支持AirPlay功能LuCI —&gt; Applications —&gt; luci-app-siitwizard  #SIIT配置向导  SIIT-WizzardLuCI —&gt; Applications —&gt; luci-app-simple-adblock  #简单的广告拦截LuCI —&gt; Applications —&gt; luci-app-smartdns  #SmartDNS本地服务器   *LuCI —&gt; Applications —&gt; luci-app-softethervirtual**  #SoftEther virtual服务器  NAT穿透   *LuCI —&gt; Applications —&gt; luci-app-splash  #Client-Splash是无线MESH网络的一个热点认证系统LuCI —&gt; Applications —&gt; luci-app-sqm  #流量智能队列管理（QOS）LuCI —&gt; Applications —&gt; luci-app-squid   #Squid代理服务器-——————————————————————————————LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus   #乳酸菌饮料兲朝上网Plus+LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include s-s New Versiong  #新SS代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include s-s Simple-obfs Plugin  #simple-obfs简单混淆工具   *LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include s-s v贰瑞 Plugin  #SS v贰瑞插件   *LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include v贰瑞  #v贰瑞代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include Trojan  #Trojan代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include Kcptun  #Kcptun代理LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include 违禁软件 Server  #乳酸菌饮料服务器LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include 违禁软件  Socks and Tunnel（已弃）LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-plus —&gt; Include Socks Server  #socks代理服务器   *-——————————————————————————————LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料-pro  #乳酸菌饮料-Pro（已弃）LuCI —&gt; Applications —&gt; luci-app-乳酸菌饮料server-python  #违禁软件 Python服务器LuCI —&gt; Applications —&gt; luci-app-statistics  #流量监控工具LuCI —&gt; Applications —&gt; luci-app-syncdial  #多拨虚拟网卡（原macvlan）LuCI —&gt; Applications —&gt; luci-app-tinyproxy  #Tinyproxy是 HTTP(S)代理服务器LuCI —&gt; Applications —&gt; luci-app-transmission   #BT下载工具LuCI —&gt; Applications —&gt; luci-app-travelmate  #旅行路由器LuCI —&gt; Applications —&gt; luci-app-ttyd   #网页终端命令行LuCI —&gt; Applications —&gt; luci-app-udpxy  #udpxy做组播服务器LuCI —&gt; Applications —&gt; luci-app-uhttpd  #uHTTPd Web服务器LuCI —&gt; Applications —&gt; luci-app-unblockmusic  #解锁网易云灰色歌曲LuCI —&gt; Applications —&gt; luci-app-unblockneteasemusic-go  #解锁网易云歌曲   *LuCI —&gt; Applications —&gt; luci-app-unbound  #Unbound DNS解析器LuCI —&gt; Applications —&gt; luci-app-upnp   #通用即插即用UPnP（端口自动转发）LuCI —&gt; Applications —&gt; luci-app-usb-printer   #USB 打印服务器LuCI —&gt; Applications —&gt; luci-app-v2瑞-server   #v2瑞 服务器LuCI —&gt; Applications —&gt; luci-app-v2瑞-pro  #v2瑞透明代理（已弃，集成乳酸菌饮料）LuCI —&gt; Applications —&gt; luci-app-verysync  #微力同步   *LuCI —&gt; Applications —&gt; luci-app-vlmcsd  #KMS服务器设置LuCI —&gt; Applications —&gt; luci-app-vnstat   #vnStat网络监控（图表）LuCI —&gt; Applications —&gt; luci-app-virtualbypass  #virtual** BypassWebUI  绕过virtual设置LuCI —&gt; Applications —&gt; luci-app-vsftpd  #FTP服务器LuCI —&gt; Applications —&gt; luci-app-watchcat  #断网检测功能与定时重启LuCI —&gt; Applications —&gt; luci-app-webadmin  #Web管理页面设置LuCI —&gt; Applications —&gt; luci-app-webshell  #网页命令行终端（已弃）LuCI —&gt; Applications —&gt; luci-app-wifischedule  #WiFi 计划LuCI —&gt; Applications —&gt; luci-app-wireguard  #virtual服务器 WireGuard状态LuCI —&gt; Applications —&gt; luci-app-wirele违禁软件egdb  #WiFi无线LuCI —&gt; Applications —&gt; luci-app-wol   #WOL网络唤醒LuCI —&gt; Applications —&gt; luci-app-wrtbwmon  #实时流量监测LuCI —&gt; Applications —&gt; luci-app-xlnetacc  #迅雷快鸟LuCI —&gt; Applications —&gt; luci-app-zerotier  #ZeroTier内网穿透-————————————————————————————————–\n5. 最后选好你要的路由，输入 make -j1 V=s （-j1 后面是线程数。第一次编译推荐用单线程，国内请尽量全局科学上网）即可开始编译你要的固件了。我一般使用 make -j1 V=99 命令编译6.第二次编译：cd lede                                                                 # 进入LEDE目录git pull                                                                # 同步更新大雕源码./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -a                 # 更新Feedsrm -rf ./tmp &amp;&amp; rm -rf .config                                          # 清除编译配置和缓存make menuconfig                                                         # 进入编译配置菜单make -jn V=99                                                           # 开始编译 n=线程数+1，例如4线程的I5填-j5本套代码保证肯定可以编译成功。里面包括了 R9 所有源代码，包括 IPK 的。第一次编译过程比较漫长，请耐心等待，也可以直接去干别的事情，慢的要好几个小时。编译完成后，编译好的固件在/lede/bin/对应的目录下，很容易找！","categories":["路由器"],"tags":["openwrt","lede"]},{"title":"浅析 JWT","url":"/2023/05/21/%E6%B5%85%E6%9E%90-JWT/","content":"来源：https://learnku.com/articles/28909\nJSON Web Token，简称 JWT，读音是 [dʒɒt]（ jot 的发音），是一种当下比较流行的「跨域认证解决方案」。注意它是一套 RFC 规范，相关的还有 JWE&#x2F;JWS&#x2F;JWK&#x2F;JOSE。它有很多优点，也有局限性，但我们可以配合其他方案做出适合自己业务的一套方案。本篇是对 JWT 做一个简单的介绍和简单实践总结。\n\n\n\nJSON Web Token (JWT) is a compact claims representation format intended for space constrained environments such as HTTP Authorization headers and URI query parameters.\n\nJWT 的组成JWT 由三部分组成：头部、数据体、签名 &#x2F; 加密。\n这三部分以 . (英文句号) 连接，注意这三部分顺序是固定的，即 header.payload.signature 如下示例：\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n1. 头部 The Header这部分用来描述 JWT 的元数据，比如该 JWT 所使用的签名 &#x2F; 加密算法、媒体类型等。\n这部分原始数据是一个 JSON 对象，经过 Base64Url 编码方式进行编码后得到最终的字符串。其中只有一个属性是必要的：alg—— 加密 &#x2F; 签名算法，默认值为 HS256。\n最简单的头部可以表示成这样：\n&#123;    &quot;alg&quot;: &quot;none&quot;&#125;\n\n其他可选属性：\n\ntyp，描述 JWT 的媒体类型，该属性的值只能是 JWT，它的作用是与其他 JOSE Header 混合时表明自己身份的一个参数（很少用到）。\ncty，描述 JWT 的内容类型。只有当需要一个 Nested JWT 时，才需要该属性，且值必须是 JWT。\nkid，KeyID，用于提示是哪个密钥参与加密。\n\n\nBase64url 编码是 Base64 的一种针对 URL 的特定变种。因为 &#x3D; 、+、&#x2F; 这个三个字符在 URL 中是有特定含义的，所以 Base64url 分别将 &#x3D; 直接忽略，+ 替换成 -，&#x2F; 替换成 _\n\n2. 数据体 The Payload这部分用来描述 JWT 的内容数据，即存放些什么。\n原始数据仍是一个 JSON 对象，经过 Base64url 编码方式进行编码后得到最终的 Payload。这里的数据默认是不加密的，所以不应存放重要数据（当然你可以考虑使用嵌套型 JWT）。官方内置了七个属性，大小写敏感，且都是可选属性，如下：\n\niss (Issuer) 签发人，即签发该 Token 的主体\nsub (Subject) 主题，即描述该 Token 的用途，一般就最为用户的唯一标识\naud (Audience) 作用域，即描述这个 Token 是给谁用的，多个的情况下该属性值为一个字符串数组，单个则为一个字符串\nexp (Expiration Time) 过期时间，即描述该 Token 在何时失效\nnbf (Not Before) 生效时间，即描述该 Token 在何时生效\niat (Issued At) 签发时间，即描述该 Token 在何时被签发的\njti (JWT ID) 唯一标识\n\n除了这几个内置属性，我们也可以自定义其他属性，自由度非常大。\n这里对 aud 做一个说明，有如下 Payload：\n&#123;    &quot;iss&quot;: &quot;server1&quot;,    &quot;aud&quot;: [&quot;http://www.a.com&quot;,&quot;http://www.b.com&quot;]&#125;\n\n那么如果我拿这个 JWT 去 http://www.c.com 获取有访问权限的资源，就会被拒绝掉，因为 aud 属性明确了这个 Token 是无权访问 www.c.com 的，有同学会说这部分反正不加密，那我本地把 www.c.com 加入进去不就完事了。别急，下面这部分看完先。\n3. 签名 &#x2F; 加密 The signature&#x2F;encryption data这部分是相对比较复杂的，因为 JWT 必须符合 JWS&#x2F;JWE 这两个规范之一，所以针对这部分的数据如何得来就有两种方式，我们先来看一个简单的例子，有如下 JWT：\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkZW1vIiwibmFtZSI6InhmbHkiLCJhZG1pbiI6dHJ1ZX0.5SHkLkM4KAHtOCtLhSNHOgkFZhPO419ukot1C5bgyUM\n\n对前两部分用 Base64url 解码后能得出相应原始数据，\nHeader 部分：\n&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;\n\nPayload 部分：\n&#123;  &quot;sub&quot;: &quot;demo&quot;,  &quot;name&quot;: &quot;xfly&quot;,  &quot;admin&quot;: true&#125;\n\n根据 Header 部分的 alg 属性我们可以知道该 JWT 符合 JWS 中的规范，且签名算法是 HS256 也就是 HMAC SHA-256 算法，那么我们就可以根据如下公式计算最后的签名部分：\nHMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)\n\n其中的密钥是保证签名安全性的关键，所以必须保存好，在本例中密钥是 123456。因为有这个密钥的存在，所以即便调用方偷偷的修改了前两部分的内容，在验证环节就会出现签名不一致的情况，所以保证了安全性。\n在实现过程中，遇到了这样一个问题：如果使用 RS256 这类非对称加密算法，加密出来的是一串二进制数据，所以第三部分还是用 Base64 编码了一层，这样最终的 JWT 就是可读的了。\nWhy JWTsJWTs 相比于在内存中使用随机 Token 的会话管理方式，其最大优势在于认证逻辑的可扩展性。举个例子，对于认证逻辑，完全可以单独部署，或者使用第三方的认证服务。\n而相比于使用数据库进行统一存储和管理 Token 的会话管理方式，其最大优势在于消耗小，不需要频繁调用数据库这类 I&#x2F;O 耗时操作。\n安全\n因为 JWT 的前两个部分仅是做了 Base64 编码处理并非加密，所以在存放数据上不能存放敏感数据。\n用来签名 &#x2F; 加密的密钥需要妥善保存。\n尽可能采用 HTTPS，确保不被窃听。\n如果存放在 Cookie 中则强烈建议开启 Http Only，其实官方推荐是放在 LocalStorage 里，然后通过 Header 头进行传递。\n\n\nCookie 的 HTTP Only 这个 Flag 和 HTTPS 并不冲突，你会发现其实还有一个 Secure 的 Flag，这个就是指 HTTPS 了，这两个 Flag 互不影响的，开启 HTTP Only 会导致前端 JavaScript 无法读取该 Cookie，更多的是为了防止 类 XSS 攻击。\n\n问题和思考JWT 的缺点其实也蛮多的，适不适用得具体看业务场景，哪个优势更大用哪个。（一点感悟：在写这篇文章前一直是 JWT 的坚定拥护者，越写越发现其实传统的 Session-Cookie 方案挺好的，很成熟。它们两者都有优缺点，选型上要多思考斟酌才行。）\n1. 数据臃肿因为 payload 只是用 Base64 编码，所以一旦存放数据大了，编码之后 JWT 会很长，cookie 很可能放不下，所以还是建议放 LocalStorage，但是每次 HTTP 请求都带上这个臃肿的 Header 开销也随之变大。\n2. 无法废弃和续签\n如果有效期设置过长，意味着这个 Token 泄漏后可以被长期利用，危害较大，所以一般我们都会设置一个较短的有效期。由于有效期较短，意味着需要经常进行重新授权的操作。\n假设在用户操作过程中升级 &#x2F; 变更了某些权限，势必需要刷新以更新数据。\n\n要解决这个问题，需要在服务端部署额外逻辑，常见的做法是增加刷新机制和黑名单机制，通过 Refresh Token 刷新 JWT，将需要废弃的 Token 加入到黑名单。\n3. Token 丢失如果认证逻辑是在自己服务器上做的话，我们的 JWT secret key 一旦丢失或者泄露那只能通过更换 key 这一种办法了，但这样做的话会导致全部用户都需要重新登录，所以 key 的保管很重要。如果我们的认证逻辑放在第三方服务上，那其实我们就完全不用操心这部分了，很贴心吧 \n我觉得 JWT 的最大优势在于可以把认证逻辑完全从应用服务中剥离出来，交给第三方 JWT 认证服务或者自己部署的认证服务器上。这样就把用户的账号密码等敏感信息放在单独的服务器上，更容易管理和维护（相比而言应用服务器更容易出现漏洞）。这样做的好处很明显：\n\n应用服务器完全不需要关心用户的账号密码，也不需要关心用户的注册登录，只需要校验 JWT 的合法性即可。\n应用服务器不需要存储 JWT 的 key，降低泄露密钥的概率。\n\n最佳实践：加密算法使用 RS256 而不是 HS256假设我们的认证逻辑放在认证服务器上（比如说第三方的认证服务），使用 HS256 算法进行加密，整个过程如下：\n\n用户通过登录接口，携带账号密码请求认证服务器\n认证服务器校验账号密码，校验失败返回登录失败信息，校验成功则进行下一步\n将用户的一些必要信息（主要是用户的唯一标识）封装成 JWT 的 payload 部分\n将 JWT 的 header、payload 分别进行 Base64url 编码，用 . 连接后与密钥一起参与 HS256 加密得到 signature\n将三部分用 . 连接后组成最终的 JWT 返回\n\n应用服务器在接收到需要认证的接口请求时，先获取请求中携带的 JWT，然后进行校验，这里我们就会看到一些问题。因为是对称式加密算法，所以加密用的密钥和解密用的密钥必须是同一个，否则是应用服务器是没法做校验的。那么我们只能把密钥在应用服务器上也保存一份，从而增加了密钥泄漏的可能性（当然也只是相比于使用非对称式加密算法而言，毕竟在应用服务器里还有很多其他的 secret key，能丢 JWT 的 key，其他 key 也能丢。。。）\n那我们使用 RS256 非对称式加密算法就不会丢了吗？是的，至少应用服务器不用背这个锅！因为应用服务器根本就不需要存储这份重要的密钥。\n简单科普下非对称式加密算法：有两个密钥，一个公开密钥和一个私有密钥，私钥参与加密，公钥用于解密，巧妙之处是解密只能用公钥来解，即便是加密用的密钥也无法对密文进行解密。你可以看到加密和解密需要两个不同的密钥，故称之为非对称加密。\n所以我们应用服务器只需要存一份公开密钥用于校验和解密认证服务器签发的 JWT 即可，即便这个公开密钥泄漏了也没事。因为用公开密钥进行加密的密文再用公开密钥去解密是解不出来的，也就是说我们的应用服务器会认为这个 JWT 是无效的！\n参考链接\nJSON Web Token Introduction - jwt.io\nRFC 7519 - JSON Web Token (JWT)\nRFC 7515 - JSON Web Signature (JWS)\nRFC 7516 - JSON Web Encryption (JWE)\nRFC 7518 - JSON Web Algorithms (JWA)\nRFC 6749 - The OAuth 2.0 Authorization Framework\nRefresh Tokens: When to Use Them and How They Interact with JWTs\nCross-origin resource sharing - Wikipedia\nJSON Web Token 入门教程 - 阮一峰的网络日志\n讲真，别再使用 JWT 了 – ThoughtWorks 洞见\nPros and cons in using JWT (JSON Web Tokens) – Rahul Golwalkar – Medium\nPros and Cons in Using JWT (JSON Web Tokens) | Hacker News\nhttps://blog.angular-university.io/angular...\nhttps://en.wikipedia.org/wiki/Public-key_c…\n\n","categories":["PHP"],"tags":["laravel","PHP"]},{"title":"私人令牌","url":"/2023/05/30/%E7%A7%81%E4%BA%BA%E4%BB%A4%E7%89%8C/","content":"\r\n  af0a78385f79214b84f7e65db006b026329716e4fdc178cbee1afc29e9d84bdc7ab826faab6892a6c65b60b9321903ee7ad7b7115b65884c53af7165a625e12f21d3422a57d8a2db132b2e6a3841fcb5\r\n  \r\n    \r\n      \r\n      \r\n        请输入与 Rhodes Island™ 取得弱神经连接时的口令：\r\n      \r\n    \r\n  \r\n\r\n","tags":["gitee"]}]